        -:    0:Source:/Users/igor/Development/theciphers/src/implementations/aes_cipher.cc
        -:    0:Graph:./DerivedData/theciphers/Build/Intermediates/theciphers.build/Debug/unit_tests.build/Objects-normal/x86_64/aes_cipher.gcno
        -:    0:Data:./DerivedData/theciphers/Build/Intermediates/theciphers.build/Debug/unit_tests.build/Objects-normal/x86_64/aes_cipher.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://
        -:    2://  AESCipher.cpp
        -:    3://  theciphers
        -:    4://
        -:    5://  Created by Igor de Oliveira Sa on 23/03/14.
        -:    6://  Copyright (c) 2014 Igor de Oliveira Sa. All rights reserved.
        -:    7://
        -:    8:
        -:    9:#include "the_ciphers.h"
        -:   10:
        -:   11:#define AES_KEYLEN 128
        -:   12:
        2:   13:AESCipher::AESCipher( const unsigned char * key, const unsigned char * iv) {
        2:   14:    key_ = (unsigned char*)key;
        1:   15:    iv_ = (unsigned char*)iv;
        -:   16:    
        1:   17:    ERR_load_crypto_strings();
        1:   18:    OpenSSL_add_all_algorithms();
        1:   19:    OPENSSL_config(NULL);
        2:   20:}
        -:   21:
        1:   22:int AESCipher::Cipher(unsigned char *message, size_t message_size, unsigned char * ciphered_message) {
        -:   23:
        1:   24:    EVP_CIPHER_CTX *ctx;
        -:   25:    
        1:   26:    int len;
        -:   27:    
        1:   28:    int ciphertext_len;
        -:   29:    
        -:   30:    /* Create and initialise the context */
        1:   31:    if(!(ctx = EVP_CIPHER_CTX_new()))
    #####:   32:        printf("erro");
        -:   33://        handleErrors();
        -:   34:    
        -:   35:    /* Initialise the encryption operation. IMPORTANT - ensure you use a key
        -:   36:     * and IV size appropriate for your cipher
        -:   37:     * In this example we are using 256 bit AES (i.e. a 256 bit key). The
        -:   38:     * IV size for *most* modes is the same as the block size. For AES this
        -:   39:     * is 128 bits */
        1:   40:    if(1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key_, iv_))
    #####:   41:        printf("erro");
        -:   42://        handleErrors();
        -:   43:    
        -:   44:    /* Provide the message to be encrypted, and obtain the encrypted output.
        -:   45:     * EVP_EncryptUpdate can be called multiple times if necessary
        -:   46:     */
        -:   47:    
        1:   48:    if(1 != EVP_EncryptUpdate(ctx, ciphered_message, &len, message, message_size))
    #####:   49:        printf("erro");
        -:   50:        //handleErrors();
        -:   51:    
        1:   52:    ciphertext_len = len;
        -:   53:    
        -:   54:    /* Finalise the encryption. Further ciphertext bytes may be written at
        -:   55:     * this stage.
        -:   56:     */
        1:   57:    if(1 != EVP_EncryptFinal_ex(ctx, ciphered_message + len, &len))
    #####:   58:        printf("erro");
        -:   59://        handleErrors();
        1:   60:    ciphertext_len += len;
        -:   61:    
        -:   62:    /* Clean up */
        1:   63:    EVP_CIPHER_CTX_free(ctx);
        -:   64:    
        1:   65:    return ciphertext_len;
        -:   66:}
        -:   67:
        1:   68:int AESCipher::Decipher(unsigned char *ciphered_message, size_t ciphered_message_size, unsigned char * deciphered_message) {
        -:   69:
        1:   70:    EVP_CIPHER_CTX *ctx;
        -:   71:    
        1:   72:    int len;
        -:   73:    
        1:   74:    int plaintext_len;
        -:   75:    
        -:   76:    /* Create and initialise the context */
        1:   77:    if(!(ctx = EVP_CIPHER_CTX_new()))
    #####:   78:        printf("erro");
        -:   79://        handleErrors();
        -:   80:    
        -:   81:    /* Initialise the decryption operation. IMPORTANT - ensure you use a key
        -:   82:     * and IV size appropriate for your cipher
        -:   83:     * In this example we are using 256 bit AES (i.e. a 256 bit key). The
        -:   84:     * IV size for *most* modes is the same as the block size. For AES this
        -:   85:     * is 128 bits */
        1:   86:    if(1 != EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key_, iv_))
    #####:   87:        printf("erro");
        -:   88:    //        handleErrors();
        -:   89:    
        -:   90:    /* Provide the message to be decrypted, and obtain the plaintext output.
        -:   91:     * EVP_DecryptUpdate can be called multiple times if necessary
        -:   92:     */
        1:   93:    if(1 != EVP_DecryptUpdate(ctx, deciphered_message, &len, ciphered_message, ciphered_message_size))
    #####:   94:        printf("erro");
        -:   95:    //        handleErrors();
        1:   96:    plaintext_len = len;
        -:   97:    
        -:   98:    /* Finalise the decryption. Further plaintext bytes may be written at
        -:   99:     * this stage.
        -:  100:     */
        1:  101:    if(1 != EVP_DecryptFinal_ex(ctx, deciphered_message + len, &len))
    #####:  102:        printf("erro");
        -:  103:    //        handleErrors();
        1:  104:    plaintext_len += len;
        -:  105:    
        -:  106:    /* Clean up */
        1:  107:    EVP_CIPHER_CTX_free(ctx);
        -:  108:
        1:  109:    return plaintext_len;
        -:  110:}
        -:  111:
        -:  112:
        -:  113:#ifdef _UNIT_TEST
        -:  114:
        8:  115:TEST(AESCipher, TestCipher) {
        1:  116:    AESCipher cipher((const unsigned char*)"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA", (const unsigned char*)"AAAAAAAAAAAAAAAA");
        -:  117:    
        1:  118:    unsigned char * message = (unsigned char *)"Hello World";
        1:  119:    size_t message_size = strlen((const char*)message) +1; // let's embbed the \0;
        -:  120:    
        1:  121:    unsigned char ciphered_message[message_size * 2];
        1:  122:    size_t ciphered_message_size = cipher.Cipher(message, message_size, ciphered_message);
        -:  123:    
        1:  124:    unsigned char deciphered_message[message_size];
        1:  125:    cipher.Decipher(ciphered_message, ciphered_message_size, deciphered_message);
        -:  126:    
        5:  127:    ASSERT_TRUE(ciphered_message_size == 16);
        6:  128:    ASSERT_STREQ((const char*)message, (const char*)deciphered_message);
        3:  129:}
        -:  130:
        -:  131:#endif
