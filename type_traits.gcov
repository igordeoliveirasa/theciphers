        -:    0:Source:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/c++/v1/type_traits
        -:    0:Graph:./DerivedData/theciphers/Build/Intermediates/theciphers.build/Debug/unit_tests.build/Objects-normal/x86_64/cipher_factory.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:// -*- C++ -*-
        -:    2://===------------------------ type_traits ---------------------------------===//
        -:    3://
        -:    4://                     The LLVM Compiler Infrastructure
        -:    5://
        -:    6:// This file is dual licensed under the MIT and the University of Illinois Open
        -:    7:// Source Licenses. See LICENSE.TXT for details.
        -:    8://
        -:    9://===----------------------------------------------------------------------===//
        -:   10:
        -:   11:#ifndef _LIBCPP_TYPE_TRAITS
        -:   12:#define _LIBCPP_TYPE_TRAITS
        -:   13:
        -:   14:/*
        -:   15:    type_traits synopsis
        -:   16:
        -:   17:namespace std
        -:   18:{
        -:   19:
        -:   20:    // helper class:
        -:   21:    template <class T, T v> struct integral_constant;
        -:   22:    typedef integral_constant<bool, true>  true_type;
        -:   23:    typedef integral_constant<bool, false> false_type;
        -:   24:
        -:   25:    // helper traits
        -:   26:    template <bool, class T = void> struct enable_if;
        -:   27:    template <bool, class T, class F> struct conditional;
        -:   28:
        -:   29:    // Primary classification traits:
        -:   30:    template <class T> struct is_void;
        -:   31:    template <class T> struct is_null_pointer;  // C++14
        -:   32:    template <class T> struct is_integral;
        -:   33:    template <class T> struct is_floating_point;
        -:   34:    template <class T> struct is_array;
        -:   35:    template <class T> struct is_pointer;
        -:   36:    template <class T> struct is_lvalue_reference;
        -:   37:    template <class T> struct is_rvalue_reference;
        -:   38:    template <class T> struct is_member_object_pointer;
        -:   39:    template <class T> struct is_member_function_pointer;
        -:   40:    template <class T> struct is_enum;
        -:   41:    template <class T> struct is_union;
        -:   42:    template <class T> struct is_class;
        -:   43:    template <class T> struct is_function;
        -:   44:
        -:   45:    // Secondary classification traits:
        -:   46:    template <class T> struct is_reference;
        -:   47:    template <class T> struct is_arithmetic;
        -:   48:    template <class T> struct is_fundamental;
        -:   49:    template <class T> struct is_member_pointer;
        -:   50:    template <class T> struct is_scalar;
        -:   51:    template <class T> struct is_object;
        -:   52:    template <class T> struct is_compound;
        -:   53:
        -:   54:    // Const-volatile properties and transformations:
        -:   55:    template <class T> struct is_const;
        -:   56:    template <class T> struct is_volatile;
        -:   57:    template <class T> struct remove_const;
        -:   58:    template <class T> struct remove_volatile;
        -:   59:    template <class T> struct remove_cv;
        -:   60:    template <class T> struct add_const;
        -:   61:    template <class T> struct add_volatile;
        -:   62:    template <class T> struct add_cv;
        -:   63:
        -:   64:    // Reference transformations:
        -:   65:    template <class T> struct remove_reference;
        -:   66:    template <class T> struct add_lvalue_reference;
        -:   67:    template <class T> struct add_rvalue_reference;
        -:   68:
        -:   69:    // Pointer transformations:
        -:   70:    template <class T> struct remove_pointer;
        -:   71:    template <class T> struct add_pointer;
        -:   72:
        -:   73:    // Integral properties:
        -:   74:    template <class T> struct is_signed;
        -:   75:    template <class T> struct is_unsigned;
        -:   76:    template <class T> struct make_signed;
        -:   77:    template <class T> struct make_unsigned;
        -:   78:
        -:   79:    // Array properties and transformations:
        -:   80:    template <class T> struct rank;
        -:   81:    template <class T, unsigned I = 0> struct extent;
        -:   82:    template <class T> struct remove_extent;
        -:   83:    template <class T> struct remove_all_extents;
        -:   84:
        -:   85:    // Member introspection:
        -:   86:    template <class T> struct is_pod;
        -:   87:    template <class T> struct is_trivial;
        -:   88:    template <class T> struct is_trivially_copyable;
        -:   89:    template <class T> struct is_standard_layout;
        -:   90:    template <class T> struct is_literal_type;
        -:   91:    template <class T> struct is_empty;
        -:   92:    template <class T> struct is_polymorphic;
        -:   93:    template <class T> struct is_abstract;
        -:   94:
        -:   95:    template <class T, class... Args> struct is_constructible;
        -:   96:    template <class T>                struct is_default_constructible;
        -:   97:    template <class T>                struct is_copy_constructible;
        -:   98:    template <class T>                struct is_move_constructible;
        -:   99:    template <class T, class U>       struct is_assignable;
        -:  100:    template <class T>                struct is_copy_assignable;
        -:  101:    template <class T>                struct is_move_assignable;
        -:  102:    template <class T>                struct is_destructible;
        -:  103:
        -:  104:    template <class T, class... Args> struct is_trivially_constructible;
        -:  105:    template <class T>                struct is_trivially_default_constructible;
        -:  106:    template <class T>                struct is_trivially_copy_constructible;
        -:  107:    template <class T>                struct is_trivially_move_constructible;
        -:  108:    template <class T, class U>       struct is_trivially_assignable;
        -:  109:    template <class T>                struct is_trivially_copy_assignable;
        -:  110:    template <class T>                struct is_trivially_move_assignable;
        -:  111:    template <class T>                struct is_trivially_destructible;
        -:  112:
        -:  113:    template <class T, class... Args> struct is_nothrow_constructible;
        -:  114:    template <class T>                struct is_nothrow_default_constructible;
        -:  115:    template <class T>                struct is_nothrow_copy_constructible;
        -:  116:    template <class T>                struct is_nothrow_move_constructible;
        -:  117:    template <class T, class U>       struct is_nothrow_assignable;
        -:  118:    template <class T>                struct is_nothrow_copy_assignable;
        -:  119:    template <class T>                struct is_nothrow_move_assignable;
        -:  120:    template <class T>                struct is_nothrow_destructible;
        -:  121:
        -:  122:    template <class T> struct has_virtual_destructor;
        -:  123:
        -:  124:    // Relationships between types:
        -:  125:    template <class T, class U> struct is_same;
        -:  126:    template <class Base, class Derived> struct is_base_of;
        -:  127:    template <class From, class To> struct is_convertible;
        -:  128:
        -:  129:    // Alignment properties and transformations:
        -:  130:    template <class T> struct alignment_of;
        -:  131:    template <size_t Len, size_t Align = most_stringent_alignment_requirement>
        -:  132:        struct aligned_storage;
        -:  133:    template <size_t Len, class... Types> struct aligned_union;
        -:  134:
        -:  135:    template <class T> struct decay;
        -:  136:    template <class... T> struct common_type;
        -:  137:    template <class T> struct underlying_type;
        -:  138:    template <class> class result_of; // undefined
        -:  139:    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;
        -:  140:
        -:  141:    // const-volatile modifications:
        -:  142:    template <class T>
        -:  143:      using remove_const_t    = typename remove_const<T>::type;  // C++14
        -:  144:    template <class T>
        -:  145:      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14
        -:  146:    template <class T>
        -:  147:      using remove_cv_t       = typename remove_cv<T>::type;  // C++14
        -:  148:    template <class T>
        -:  149:      using add_const_t       = typename add_const<T>::type;  // C++14
        -:  150:    template <class T>
        -:  151:      using add_volatile_t    = typename add_volatile<T>::type;  // C++14
        -:  152:    template <class T>
        -:  153:      using add_cv_t          = typename add_cv<T>::type;  // C++14
        -:  154:  
        -:  155:    // reference modifications:
        -:  156:    template <class T>
        -:  157:      using remove_reference_t     = typename remove_reference<T>::type;  // C++14
        -:  158:    template <class T>
        -:  159:      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14
        -:  160:    template <class T>
        -:  161:      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14
        -:  162:  
        -:  163:    // sign modifications:
        -:  164:    template <class T>
        -:  165:      using make_signed_t   = typename make_signed<T>::type;  // C++14
        -:  166:    template <class T>
        -:  167:      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14
        -:  168:  
        -:  169:    // array modifications:
        -:  170:    template <class T>
        -:  171:      using remove_extent_t      = typename remove_extent<T>::type;  // C++14
        -:  172:    template <class T>
        -:  173:      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14
        -:  174:
        -:  175:    // pointer modifications:
        -:  176:    template <class T>
        -:  177:      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14
        -:  178:    template <class T>
        -:  179:      using add_pointer_t    = typename add_pointer<T>::type;  // C++14
        -:  180:
        -:  181:    // other transformations:
        -:  182:    template <size_t Len, std::size_t Align=default-alignment>
        -:  183:      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14
        -:  184:    template <std::size_t Len, class... Types>
        -:  185:      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14
        -:  186:    template <class T>
        -:  187:      using decay_t           = typename decay<T>::type;  // C++14
        -:  188:    template <bool b, class T=void>
        -:  189:      using enable_if_t       = typename enable_if<b,T>::type;  // C++14
        -:  190:    template <bool b, class T, class F>
        -:  191:      using conditional_t     = typename conditional<b,T,F>::type;  // C++14
        -:  192:    template <class... T>
        -:  193:      using common_type_t     = typename common_type<T...>::type;  // C++14
        -:  194:    template <class T>
        -:  195:      using underlying_type_t = typename underlying_type<T>::type;  // C++14
        -:  196:    template <class F, class... ArgTypes>
        -:  197:      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14
        -:  198:
        -:  199:}  // std
        -:  200:
        -:  201:*/
        -:  202:#include <__config>
        -:  203:#include <cstddef>
        -:  204:
        -:  205:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  206:#pragma GCC system_header
        -:  207:#endif
        -:  208:
        -:  209:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  210:
        -:  211:template <bool _Bp, class _If, class _Then>
        -:  212:    struct _LIBCPP_TYPE_VIS_ONLY conditional {typedef _If type;};
        -:  213:template <class _If, class _Then>
        -:  214:    struct _LIBCPP_TYPE_VIS_ONLY conditional<false, _If, _Then> {typedef _Then type;};
        -:  215:
        -:  216:#if _LIBCPP_STD_VER > 11
        -:  217:template <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;
        -:  218:#endif
        -:  219:
        -:  220:template <bool, class _Tp = void> struct _LIBCPP_TYPE_VIS_ONLY enable_if {};
        -:  221:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY enable_if<true, _Tp> {typedef _Tp type;};
        -:  222:
        -:  223:#if _LIBCPP_STD_VER > 11
        -:  224:template <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;
        -:  225:#endif
        -:  226:
        -:  227:
        -:  228:struct __two {char __lx[2];};
        -:  229:
        -:  230:// helper class:
        -:  231:
        -:  232:template <class _Tp, _Tp __v>
        -:  233:struct _LIBCPP_TYPE_VIS_ONLY integral_constant
        -:  234:{
        -:  235:    static _LIBCPP_CONSTEXPR const _Tp      value = __v;
        -:  236:    typedef _Tp               value_type;
        -:  237:    typedef integral_constant type;
        -:  238:    _LIBCPP_INLINE_VISIBILITY
        -:  239:        _LIBCPP_CONSTEXPR operator value_type() const {return value;}
        -:  240:#if _LIBCPP_STD_VER > 11
        -:  241:    _LIBCPP_INLINE_VISIBILITY
        -:  242:         constexpr value_type operator ()() const {return value;}
        -:  243:#endif
        -:  244:};
        -:  245:
        -:  246:template <class _Tp, _Tp __v>
        -:  247:_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;
        -:  248:
        -:  249:typedef integral_constant<bool, true>  true_type;
        -:  250:typedef integral_constant<bool, false> false_type;
        -:  251:
        -:  252:// is_const
        -:  253:
        -:  254:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const            : public false_type {};
        -:  255:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const<_Tp const> : public true_type {};
        -:  256:
        -:  257:// is_volatile
        -:  258:
        -:  259:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile               : public false_type {};
        -:  260:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile<_Tp volatile> : public true_type {};
        -:  261:
        -:  262:// remove_const
        -:  263:
        -:  264:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const            {typedef _Tp type;};
        -:  265:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const<const _Tp> {typedef _Tp type;};
        -:  266:#if _LIBCPP_STD_VER > 11
        -:  267:template <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;
        -:  268:#endif
        -:  269:
        -:  270:// remove_volatile
        -:  271:
        -:  272:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile               {typedef _Tp type;};
        -:  273:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile<volatile _Tp> {typedef _Tp type;};
        -:  274:#if _LIBCPP_STD_VER > 11
        -:  275:template <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;
        -:  276:#endif
        -:  277:
        -:  278:// remove_cv
        -:  279:
        -:  280:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_cv
        -:  281:{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};
        -:  282:#if _LIBCPP_STD_VER > 11
        -:  283:template <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;
        -:  284:#endif
        -:  285:
        -:  286:// is_void
        -:  287:
        -:  288:template <class _Tp> struct __is_void       : public false_type {};
        -:  289:template <>          struct __is_void<void> : public true_type {};
        -:  290:
        -:  291:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_void
        -:  292:    : public __is_void<typename remove_cv<_Tp>::type> {};
        -:  293:
        -:  294:// __is_nullptr_t
        -:  295:
        -:  296:template <class _Tp> struct ____is_nullptr_t       : public false_type {};
        -:  297:template <>          struct ____is_nullptr_t<nullptr_t> : public true_type {};
        -:  298:
        -:  299:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __is_nullptr_t
        -:  300:    : public ____is_nullptr_t<typename remove_cv<_Tp>::type> {};
        -:  301:
        -:  302:#if _LIBCPP_STD_VER > 11
        -:  303:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_null_pointer
        -:  304:    : public ____is_nullptr_t<typename remove_cv<_Tp>::type> {};
        -:  305:#endif
        -:  306:
        -:  307:// is_integral
        -:  308:
        -:  309:template <class _Tp> struct __is_integral                     : public false_type {};
        -:  310:template <>          struct __is_integral<bool>               : public true_type {};
        -:  311:template <>          struct __is_integral<char>               : public true_type {};
        -:  312:template <>          struct __is_integral<signed char>        : public true_type {};
        -:  313:template <>          struct __is_integral<unsigned char>      : public true_type {};
        -:  314:template <>          struct __is_integral<wchar_t>            : public true_type {};
        -:  315:#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS
        -:  316:template <>          struct __is_integral<char16_t>           : public true_type {};
        -:  317:template <>          struct __is_integral<char32_t>           : public true_type {};
        -:  318:#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS
        -:  319:template <>          struct __is_integral<short>              : public true_type {};
        -:  320:template <>          struct __is_integral<unsigned short>     : public true_type {};
        -:  321:template <>          struct __is_integral<int>                : public true_type {};
        -:  322:template <>          struct __is_integral<unsigned int>       : public true_type {};
        -:  323:template <>          struct __is_integral<long>               : public true_type {};
        -:  324:template <>          struct __is_integral<unsigned long>      : public true_type {};
        -:  325:template <>          struct __is_integral<long long>          : public true_type {};
        -:  326:template <>          struct __is_integral<unsigned long long> : public true_type {};
        -:  327:
        -:  328:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_integral
        -:  329:    : public __is_integral<typename remove_cv<_Tp>::type> {};
        -:  330:
        -:  331:// is_floating_point
        -:  332:
        -:  333:template <class _Tp> struct __is_floating_point              : public false_type {};
        -:  334:template <>          struct __is_floating_point<float>       : public true_type {};
        -:  335:template <>          struct __is_floating_point<double>      : public true_type {};
        -:  336:template <>          struct __is_floating_point<long double> : public true_type {};
        -:  337:
        -:  338:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_floating_point
        -:  339:    : public __is_floating_point<typename remove_cv<_Tp>::type> {};
        -:  340:
        -:  341:// is_array
        -:  342:
        -:  343:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array
        -:  344:    : public false_type {};
        -:  345:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[]>
        -:  346:    : public true_type {};
        -:  347:template <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[_Np]>
        -:  348:    : public true_type {};
        -:  349:
        -:  350:// is_pointer
        -:  351:
        -:  352:template <class _Tp> struct __is_pointer       : public false_type {};
        -:  353:template <class _Tp> struct __is_pointer<_Tp*> : public true_type {};
        -:  354:
        -:  355:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pointer
        -:  356:    : public __is_pointer<typename remove_cv<_Tp>::type> {};
        -:  357:
        -:  358:// is_reference
        -:  359:
        -:  360:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference       : public false_type {};
        -:  361:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference<_Tp&> : public true_type {};
        -:  362:
        -:  363:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference        : public false_type {};
        -:  364:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  365:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference<_Tp&&> : public true_type {};
        -:  366:#endif
        -:  367:
        -:  368:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference        : public false_type {};
        -:  369:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&>  : public true_type {};
        -:  370:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  371:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&&> : public true_type {};
        -:  372:#endif
        -:  373:
        -:  374:#if defined(__clang__) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -:  375:#define _LIBCPP_HAS_TYPE_TRAITS
        -:  376:#endif
        -:  377:
        -:  378:// is_union
        -:  379:
        -:  380:#if __has_feature(is_union) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -:  381:
        -:  382:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union
        -:  383:    : public integral_constant<bool, __is_union(_Tp)> {};
        -:  384:
        -:  385:#else
        -:  386:
        -:  387:template <class _Tp> struct __libcpp_union : public false_type {};
        -:  388:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union
        -:  389:    : public __libcpp_union<typename remove_cv<_Tp>::type> {};
        -:  390:
        -:  391:#endif
        -:  392:
        -:  393:// is_class
        -:  394:
        -:  395:#if __has_feature(is_class) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -:  396:
        -:  397:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class
        -:  398:    : public integral_constant<bool, __is_class(_Tp)> {};
        -:  399:
        -:  400:#else
        -:  401:
        -:  402:namespace __is_class_imp
        -:  403:{
        -:  404:template <class _Tp> char  __test(int _Tp::*);
        -:  405:template <class _Tp> __two __test(...);
        -:  406:}
        -:  407:
        -:  408:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class
        -:  409:    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};
        -:  410:
        -:  411:#endif
        -:  412:
        -:  413:// is_same
        -:  414:
        -:  415:template <class _Tp, class _Up> struct _LIBCPP_TYPE_VIS_ONLY is_same           : public false_type {};
        -:  416:template <class _Tp>            struct _LIBCPP_TYPE_VIS_ONLY is_same<_Tp, _Tp> : public true_type {};
        -:  417:
        -:  418:// is_function
        -:  419:
        -:  420:namespace __is_function_imp
        -:  421:{
        -:  422:template <class _Tp> char  __test(_Tp*);
        -:  423:template <class _Tp> __two __test(...);
        -:  424:template <class _Tp> _Tp&  __source();
        -:  425:}
        -:  426:
        -:  427:template <class _Tp, bool = is_class<_Tp>::value ||
        -:  428:                            is_union<_Tp>::value ||
        -:  429:                            is_void<_Tp>::value  ||
        -:  430:                            is_reference<_Tp>::value ||
        -:  431:                            __is_nullptr_t<_Tp>::value >
        -:  432:struct __is_function
        -:  433:    : public integral_constant<bool, sizeof(__is_function_imp::__test<_Tp>(__is_function_imp::__source<_Tp>())) == 1>
        -:  434:    {};
        -:  435:template <class _Tp> struct __is_function<_Tp, true> : public false_type {};
        -:  436:
        -:  437:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_function
        -:  438:    : public __is_function<_Tp> {};
        -:  439:
        -:  440:// is_member_function_pointer
        -:  441:
        -:  442:template <class _Tp> struct            __is_member_function_pointer             : public false_type {};
        -:  443:template <class _Tp, class _Up> struct __is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};
        -:  444:
        -:  445:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_function_pointer
        -:  446:    : public __is_member_function_pointer<typename remove_cv<_Tp>::type> {};
        -:  447:
        -:  448:// is_member_pointer
        -:  449:
        -:  450:template <class _Tp>            struct __is_member_pointer             : public false_type {};
        -:  451:template <class _Tp, class _Up> struct __is_member_pointer<_Tp _Up::*> : public true_type {};
        -:  452:
        -:  453:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_pointer
        -:  454:    : public __is_member_pointer<typename remove_cv<_Tp>::type> {};
        -:  455:
        -:  456:// is_member_object_pointer
        -:  457:
        -:  458:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_object_pointer
        -:  459:    : public integral_constant<bool, is_member_pointer<_Tp>::value &&
        -:  460:                                    !is_member_function_pointer<_Tp>::value> {};
        -:  461:
        -:  462:// is_enum
        -:  463:
        -:  464:#if __has_feature(is_enum) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -:  465:
        -:  466:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum
        -:  467:    : public integral_constant<bool, __is_enum(_Tp)> {};
        -:  468:
        -:  469:#else
        -:  470:
        -:  471:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum
        -:  472:    : public integral_constant<bool, !is_void<_Tp>::value             &&
        -:  473:                                     !is_integral<_Tp>::value         &&
        -:  474:                                     !is_floating_point<_Tp>::value   &&
        -:  475:                                     !is_array<_Tp>::value            &&
        -:  476:                                     !is_pointer<_Tp>::value          &&
        -:  477:                                     !is_reference<_Tp>::value        &&
        -:  478:                                     !is_member_pointer<_Tp>::value   &&
        -:  479:                                     !is_union<_Tp>::value            &&
        -:  480:                                     !is_class<_Tp>::value            &&
        -:  481:                                     !is_function<_Tp>::value         > {};
        -:  482:
        -:  483:#endif
        -:  484:
        -:  485:// is_arithmetic
        -:  486:
        -:  487:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_arithmetic
        -:  488:    : public integral_constant<bool, is_integral<_Tp>::value      ||
        -:  489:                                     is_floating_point<_Tp>::value> {};
        -:  490:
        -:  491:// is_fundamental
        -:  492:
        -:  493:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_fundamental
        -:  494:    : public integral_constant<bool, is_void<_Tp>::value        ||
        -:  495:                                     __is_nullptr_t<_Tp>::value ||
        -:  496:                                     is_arithmetic<_Tp>::value> {};
        -:  497:
        -:  498:// is_scalar
        -:  499:
        -:  500:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_scalar
        -:  501:    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||
        -:  502:                                     is_member_pointer<_Tp>::value ||
        -:  503:                                     is_pointer<_Tp>::value        ||
        -:  504:                                     __is_nullptr_t<_Tp>::value    ||
        -:  505:                                     is_enum<_Tp>::value           > {};
        -:  506:
        -:  507:template <> struct _LIBCPP_TYPE_VIS_ONLY is_scalar<nullptr_t> : public true_type {};
        -:  508:
        -:  509:// is_object
        -:  510:
        -:  511:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_object
        -:  512:    : public integral_constant<bool, is_scalar<_Tp>::value ||
        -:  513:                                     is_array<_Tp>::value  ||
        -:  514:                                     is_union<_Tp>::value  ||
        -:  515:                                     is_class<_Tp>::value  > {};
        -:  516:
        -:  517:// is_compound
        -:  518:
        -:  519:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_compound
        -:  520:    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};
        -:  521:
        -:  522:// add_const
        -:  523:
        -:  524:template <class _Tp, bool = is_reference<_Tp>::value ||
        -:  525:                            is_function<_Tp>::value  ||
        -:  526:                            is_const<_Tp>::value     >
        -:  527:struct __add_const             {typedef _Tp type;};
        -:  528:
        -:  529:template <class _Tp>
        -:  530:struct __add_const<_Tp, false> {typedef const _Tp type;};
        -:  531:
        -:  532:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_const
        -:  533:    {typedef typename __add_const<_Tp>::type type;};
        -:  534:
        -:  535:#if _LIBCPP_STD_VER > 11
        -:  536:template <class _Tp> using add_const_t = typename add_const<_Tp>::type;
        -:  537:#endif
        -:  538:
        -:  539:// add_volatile
        -:  540:
        -:  541:template <class _Tp, bool = is_reference<_Tp>::value ||
        -:  542:                            is_function<_Tp>::value  ||
        -:  543:                            is_volatile<_Tp>::value  >
        -:  544:struct __add_volatile             {typedef _Tp type;};
        -:  545:
        -:  546:template <class _Tp>
        -:  547:struct __add_volatile<_Tp, false> {typedef volatile _Tp type;};
        -:  548:
        -:  549:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_volatile
        -:  550:    {typedef typename __add_volatile<_Tp>::type type;};
        -:  551:
        -:  552:#if _LIBCPP_STD_VER > 11
        -:  553:template <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;
        -:  554:#endif
        -:  555:
        -:  556:// add_cv
        -:  557:
        -:  558:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_cv
        -:  559:    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};
        -:  560:
        -:  561:#if _LIBCPP_STD_VER > 11
        -:  562:template <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;
        -:  563:#endif
        -:  564:
        -:  565:// remove_reference
        -:  566:
        -:  567:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference        {typedef _Tp type;};
        -:  568:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&>  {typedef _Tp type;};
        -:  569:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  570:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&&> {typedef _Tp type;};
        -:  571:#endif
        -:  572:
        -:  573:#if _LIBCPP_STD_VER > 11
        -:  574:template <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;
        -:  575:#endif
        -:  576:
        -:  577:// add_lvalue_reference
        -:  578:
        -:  579:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference                      {typedef _Tp& type;};
        -:  580:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<_Tp&>                {typedef _Tp& type;};  // for older compiler
        -:  581:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<void>                {typedef void type;};
        -:  582:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const void>          {typedef const void type;};
        -:  583:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<volatile void>       {typedef volatile void type;};
        -:  584:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const volatile void> {typedef const volatile void type;};
        -:  585:
        -:  586:#if _LIBCPP_STD_VER > 11
        -:  587:template <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;
        -:  588:#endif
        -:  589:
        -:  590:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  591:
        -:  592:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY  add_rvalue_reference                     {typedef _Tp&& type;};
        -:  593:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<void>                {typedef void type;};
        -:  594:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const void>          {typedef const void type;};
        -:  595:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<volatile void>       {typedef volatile void type;};
        -:  596:template <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const volatile void> {typedef const volatile void type;};
        -:  597:
        -:  598:#if _LIBCPP_STD_VER > 11
        -:  599:template <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;
        -:  600:#endif
        -:  601:
        -:  602:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  603:
        -:  604:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  605:
        -:  606:template <class _Tp>
        -:  607:typename add_rvalue_reference<_Tp>::type
        -:  608:declval() _NOEXCEPT;
        -:  609:
        -:  610:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  611:
        -:  612:template <class _Tp>
        -:  613:typename add_lvalue_reference<_Tp>::type
        -:  614:declval();
        -:  615:
        -:  616:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  617:
        -:  618:struct __any
        -:  619:{
        -:  620:    __any(...);
        -:  621:};
        -:  622:
        -:  623:// remove_pointer
        -:  624:
        -:  625:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer                      {typedef _Tp type;};
        -:  626:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp*>                {typedef _Tp type;};
        -:  627:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const>          {typedef _Tp type;};
        -:  628:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* volatile>       {typedef _Tp type;};
        -:  629:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const volatile> {typedef _Tp type;};
        -:  630:
        -:  631:#if _LIBCPP_STD_VER > 11
        -:  632:template <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;
        -:  633:#endif
        -:  634:
        -:  635:// add_pointer
        -:  636:
        -:  637:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_pointer
        -:  638:    {typedef typename remove_reference<_Tp>::type* type;};
        -:  639:
        -:  640:#if _LIBCPP_STD_VER > 11
        -:  641:template <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;
        -:  642:#endif
        -:  643:
        -:  644:// is_signed
        -:  645:
        -:  646:template <class _Tp, bool = is_integral<_Tp>::value>
        -:  647:struct ___is_signed : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};
        -:  648:
        -:  649:template <class _Tp>
        -:  650:struct ___is_signed<_Tp, false> : public true_type {};  // floating point
        -:  651:
        -:  652:template <class _Tp, bool = is_arithmetic<_Tp>::value>
        -:  653:struct __is_signed : public ___is_signed<_Tp> {};
        -:  654:
        -:  655:template <class _Tp> struct __is_signed<_Tp, false> : public false_type {};
        -:  656:
        -:  657:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_signed : public __is_signed<_Tp> {};
        -:  658:
        -:  659:// is_unsigned
        -:  660:
        -:  661:template <class _Tp, bool = is_integral<_Tp>::value>
        -:  662:struct ___is_unsigned : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};
        -:  663:
        -:  664:template <class _Tp>
        -:  665:struct ___is_unsigned<_Tp, false> : public false_type {};  // floating point
        -:  666:
        -:  667:template <class _Tp, bool = is_arithmetic<_Tp>::value>
        -:  668:struct __is_unsigned : public ___is_unsigned<_Tp> {};
        -:  669:
        -:  670:template <class _Tp> struct __is_unsigned<_Tp, false> : public false_type {};
        -:  671:
        -:  672:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_unsigned : public __is_unsigned<_Tp> {};
        -:  673:
        -:  674:// rank
        -:  675:
        -:  676:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank
        -:  677:    : public integral_constant<size_t, 0> {};
        -:  678:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[]>
        -:  679:    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
        -:  680:template <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[_Np]>
        -:  681:    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
        -:  682:
        -:  683:// extent
        -:  684:
        -:  685:template <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TYPE_VIS_ONLY extent
        -:  686:    : public integral_constant<size_t, 0> {};
        -:  687:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], 0>
        -:  688:    : public integral_constant<size_t, 0> {};
        -:  689:template <class _Tp, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], _Ip>
        -:  690:    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
        -:  691:template <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], 0>
        -:  692:    : public integral_constant<size_t, _Np> {};
        -:  693:template <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], _Ip>
        -:  694:    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
        -:  695:
        -:  696:// remove_extent
        -:  697:
        -:  698:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent
        -:  699:    {typedef _Tp type;};
        -:  700:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[]>
        -:  701:    {typedef _Tp type;};
        -:  702:template <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[_Np]>
        -:  703:    {typedef _Tp type;};
        -:  704:
        -:  705:#if _LIBCPP_STD_VER > 11
        -:  706:template <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;
        -:  707:#endif
        -:  708:
        -:  709:// remove_all_extents
        -:  710:
        -:  711:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents
        -:  712:    {typedef _Tp type;};
        -:  713:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[]>
        -:  714:    {typedef typename remove_all_extents<_Tp>::type type;};
        -:  715:template <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[_Np]>
        -:  716:    {typedef typename remove_all_extents<_Tp>::type type;};
        -:  717:
        -:  718:#if _LIBCPP_STD_VER > 11
        -:  719:template <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
        -:  720:#endif
        -:  721:
        -:  722:// decay
        -:  723:
        -:  724:template <class _Tp>
        -:  725:struct _LIBCPP_TYPE_VIS_ONLY decay
        -:  726:{
        -:  727:private:
        -:  728:    typedef typename remove_reference<_Tp>::type _Up;
        -:  729:public:
        -:  730:    typedef typename conditional
        -:  731:                     <
        -:  732:                         is_array<_Up>::value,
        -:  733:                         typename remove_extent<_Up>::type*,
        -:  734:                         typename conditional
        -:  735:                         <
        -:  736:                              is_function<_Up>::value,
        -:  737:                              typename add_pointer<_Up>::type,
        -:  738:                              typename remove_cv<_Up>::type
        -:  739:                         >::type
        -:  740:                     >::type type;
        -:  741:};
        -:  742:
        -:  743:#if _LIBCPP_STD_VER > 11
        -:  744:template <class _Tp> using decay_t = typename decay<_Tp>::type;
        -:  745:#endif
        -:  746:
        -:  747:// is_abstract
        -:  748:
        -:  749:namespace __is_abstract_imp
        -:  750:{
        -:  751:template <class _Tp> char  __test(_Tp (*)[1]);
        -:  752:template <class _Tp> __two __test(...);
        -:  753:}
        -:  754:
        -:  755:template <class _Tp, bool = is_class<_Tp>::value>
        -:  756:struct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};
        -:  757:
        -:  758:template <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};
        -:  759:
        -:  760:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_abstract : public __libcpp_abstract<_Tp> {};
        -:  761:
        -:  762:// is_base_of
        -:  763:
        -:  764:#ifdef _LIBCPP_HAS_IS_BASE_OF
        -:  765:
        -:  766:template <class _Bp, class _Dp>
        -:  767:struct _LIBCPP_TYPE_VIS_ONLY is_base_of
        -:  768:    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
        -:  769:
        -:  770:#else  // __has_feature(is_base_of)
        -:  771:
        -:  772:namespace __is_base_of_imp
        -:  773:{
        -:  774:template <class _Tp>
        -:  775:struct _Dst
        -:  776:{
        -:  777:    _Dst(const volatile _Tp &);
        -:  778:};
        -:  779:template <class _Tp>
        -:  780:struct _Src
        -:  781:{
        -:  782:    operator const volatile _Tp &();
        -:  783:    template <class _Up> operator const _Dst<_Up> &();
        -:  784:};
        -:  785:template <size_t> struct __one { typedef char type; };
        -:  786:template <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);
        -:  787:template <class _Bp, class _Dp> __two __test(...);
        -:  788:}
        -:  789:
        -:  790:template <class _Bp, class _Dp>
        -:  791:struct _LIBCPP_TYPE_VIS_ONLY is_base_of
        -:  792:    : public integral_constant<bool, is_class<_Bp>::value &&
        -:  793:                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};
        -:  794:
        -:  795:#endif  // __has_feature(is_base_of)
        -:  796:
        -:  797:// is_convertible
        -:  798:
        -:  799:#if __has_feature(is_convertible_to)
        -:  800:
        -:  801:template <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible
        -:  802:    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&
        -:  803:                                     !is_abstract<_T2>::value> {};
        -:  804:
        -:  805:#else  // __has_feature(is_convertible_to)
        -:  806:
        -:  807:namespace __is_convertible_imp
        -:  808:{
        -:  809:template <class _Tp> char  __test(_Tp);
        -:  810:template <class _Tp> __two __test(...);
        -:  811:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  812:template <class _Tp> _Tp&& __source();
        -:  813:#else
        -:  814:template <class _Tp> typename remove_reference<_Tp>::type& __source();
        -:  815:#endif
        -:  816:
        -:  817:template <class _Tp, bool _IsArray =    is_array<_Tp>::value,
        -:  818:                     bool _IsFunction = is_function<_Tp>::value,
        -:  819:                     bool _IsVoid =     is_void<_Tp>::value>
        -:  820:                     struct __is_array_function_or_void                          {enum {value = 0};};
        -:  821:template <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};
        -:  822:template <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};
        -:  823:template <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};
        -:  824:}
        -:  825:
        -:  826:template <class _Tp,
        -:  827:    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>
        -:  828:struct __is_convertible_check
        -:  829:{
        -:  830:    static const size_t __v = 0;
        -:  831:};
        -:  832:
        -:  833:template <class _Tp>
        -:  834:struct __is_convertible_check<_Tp, 0>
        -:  835:{
        -:  836:    static const size_t __v = sizeof(_Tp);
        -:  837:};
        -:  838:
        -:  839:template <class _T1, class _T2,
        -:  840:    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,
        -:  841:    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>
        -:  842:struct __is_convertible
        -:  843:    : public integral_constant<bool,
        -:  844:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  845:        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1
        -:  846:#else
        -:  847:        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1
        -:  848:         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value
        -:  849:              && (!is_const<typename remove_reference<_T2>::type>::value
        -:  850:                  || is_volatile<typename remove_reference<_T2>::type>::value)
        -:  851:                  && (is_same<typename remove_cv<_T1>::type,
        -:  852:                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value
        -:  853:                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))
        -:  854:#endif
        -:  855:    >
        -:  856:{};
        -:  857:
        -:  858:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 0> : false_type {};
        -:  859:
        -:  860:template <class _T1> struct __is_convertible<_T1, const _T1&, 1, 0> : true_type {};
        -:  861:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  862:template <class _T1> struct __is_convertible<_T1, _T1&&, 1, 0> : true_type {};
        -:  863:template <class _T1> struct __is_convertible<_T1, const _T1&&, 1, 0> : true_type {};
        -:  864:template <class _T1> struct __is_convertible<_T1, volatile _T1&&, 1, 0> : true_type {};
        -:  865:template <class _T1> struct __is_convertible<_T1, const volatile _T1&&, 1, 0> : true_type {};
        -:  866:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  867:
        -:  868:template <class _T1, class _T2> struct __is_convertible<_T1, _T2*, 1, 0>
        -:  869:    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*>::value> {};
        -:  870:
        -:  871:template <class _T1, class _T2> struct __is_convertible<_T1, _T2* const, 1, 0>
        -:  872:    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const>::value> {};
        -:  873:
        -:  874:template <class _T1, class _T2> struct __is_convertible<_T1, _T2* volatile, 1, 0>
        -:  875:    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*volatile>::value> {};
        -:  876:
        -:  877:template <class _T1, class _T2> struct __is_convertible<_T1, _T2* const volatile, 1, 0>
        -:  878:    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const volatile>::value> {};
        -:  879:
        -:  880:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 0>                : public false_type {};
        -:  881:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  882:template <class _T1>            struct __is_convertible<_T1, _T1&&, 2, 0>               : public true_type {};
        -:  883:#endif
        -:  884:template <class _T1>            struct __is_convertible<_T1, _T1&, 2, 0>               : public true_type {};
        -:  885:template <class _T1>            struct __is_convertible<_T1, _T1*, 2, 0>               : public true_type {};
        -:  886:template <class _T1>            struct __is_convertible<_T1, _T1*const, 2, 0>          : public true_type {};
        -:  887:template <class _T1>            struct __is_convertible<_T1, _T1*volatile, 2, 0>       : public true_type {};
        -:  888:template <class _T1>            struct __is_convertible<_T1, _T1*const volatile, 2, 0> : public true_type {};
        -:  889:
        -:  890:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 0> : public false_type {};
        -:  891:
        -:  892:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};
        -:  893:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};
        -:  894:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};
        -:  895:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};
        -:  896:
        -:  897:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};
        -:  898:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};
        -:  899:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};
        -:  900:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};
        -:  901:
        -:  902:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};
        -:  903:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};
        -:  904:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};
        -:  905:template <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};
        -:  906:
        -:  907:template <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible
        -:  908:    : public __is_convertible<_T1, _T2>
        -:  909:{
        -:  910:    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;
        -:  911:    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;
        -:  912:};
        -:  913:
        -:  914:#endif  // __has_feature(is_convertible_to)
        -:  915:
        -:  916:// is_empty
        -:  917:
        -:  918:#if __has_feature(is_empty)
        -:  919:
        -:  920:template <class _Tp>
        -:  921:struct _LIBCPP_TYPE_VIS_ONLY is_empty
        -:  922:    : public integral_constant<bool, __is_empty(_Tp)> {};
        -:  923:
        -:  924:#else  // __has_feature(is_empty)
        -:  925:
        -:  926:template <class _Tp>
        -:  927:struct __is_empty1
        -:  928:    : public _Tp
        -:  929:{
        -:  930:    double __lx;
        -:  931:};
        -:  932:
        -:  933:struct __is_empty2
        -:  934:{
        -:  935:    double __lx;
        -:  936:};
        -:  937:
        -:  938:template <class _Tp, bool = is_class<_Tp>::value>
        -:  939:struct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
        -:  940:
        -:  941:template <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};
        -:  942:
        -:  943:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_empty : public __libcpp_empty<_Tp> {};
        -:  944:
        -:  945:#endif  // __has_feature(is_empty)
        -:  946:
        -:  947:// is_polymorphic
        -:  948:
        -:  949:#if __has_feature(is_polymorphic)
        -:  950:
        -:  951:template <class _Tp>
        -:  952:struct _LIBCPP_TYPE_VIS_ONLY is_polymorphic
        -:  953:    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
        -:  954:
        -:  955:#else
        -:  956:
        -:  957:template<typename _Tp> char &__is_polymorphic_impl(
        -:  958:    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,
        -:  959:                       int>::type);
        -:  960:template<typename _Tp> __two &__is_polymorphic_impl(...);
        -:  961:
        -:  962:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_polymorphic
        -:  963:    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};
        -:  964:
        -:  965:#endif // __has_feature(is_polymorphic)
        -:  966:
        -:  967:// has_virtual_destructor
        -:  968:
        -:  969:#if __has_feature(has_virtual_destructor) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -:  970:
        -:  971:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor
        -:  972:    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
        -:  973:
        -:  974:#else  // _LIBCPP_HAS_TYPE_TRAITS
        -:  975:
        -:  976:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor
        -:  977:    : public false_type {};
        -:  978:
        -:  979:#endif  // _LIBCPP_HAS_TYPE_TRAITS
        -:  980:
        -:  981:// alignment_of
        -:  982:
        -:  983:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY alignment_of
        -:  984:    : public integral_constant<size_t, __alignof__(_Tp)> {};
        -:  985:
        -:  986:// aligned_storage
        -:  987:
        -:  988:template <class _Hp, class _Tp>
        -:  989:struct __type_list
        -:  990:{
        -:  991:    typedef _Hp _Head;
        -:  992:    typedef _Tp _Tail;
        -:  993:};
        -:  994:
        -:  995:struct __nat
        -:  996:{
        -:  997:#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
        -:  998:    __nat() = delete;
        -:  999:    __nat(const __nat&) = delete;
        -: 1000:    __nat& operator=(const __nat&) = delete;
        -: 1001:    ~__nat() = delete;
        -: 1002:#endif
        -: 1003:};
        -: 1004:
        -: 1005:template <class _Tp>
        -: 1006:struct __align_type
        -: 1007:{
        -: 1008:    static const size_t value = alignment_of<_Tp>::value;
        -: 1009:    typedef _Tp type;
        -: 1010:};
        -: 1011:
        -: 1012:struct __struct_double {long double __lx;};
        -: 1013:struct __struct_double4 {double __lx[4];};
        -: 1014:
        -: 1015:typedef
        -: 1016:    __type_list<__align_type<unsigned char>,
        -: 1017:    __type_list<__align_type<unsigned short>,
        -: 1018:    __type_list<__align_type<unsigned int>,
        -: 1019:    __type_list<__align_type<unsigned long>,
        -: 1020:    __type_list<__align_type<unsigned long long>,
        -: 1021:    __type_list<__align_type<double>,
        -: 1022:    __type_list<__align_type<long double>,
        -: 1023:    __type_list<__align_type<__struct_double>,
        -: 1024:    __type_list<__align_type<__struct_double4>,
        -: 1025:    __type_list<__align_type<int*>,
        -: 1026:    __nat
        -: 1027:    > > > > > > > > > > __all_types;
        -: 1028:
        -: 1029:template <class _TL, size_t _Align> struct __find_pod;
        -: 1030:
        -: 1031:template <class _Hp, size_t _Align>
        -: 1032:struct __find_pod<__type_list<_Hp, __nat>, _Align>
        -: 1033:{
        -: 1034:    typedef typename conditional<
        -: 1035:                             _Align == _Hp::value,
        -: 1036:                             typename _Hp::type,
        -: 1037:                             void
        -: 1038:                         >::type type;
        -: 1039:};
        -: 1040:
        -: 1041:template <class _Hp, class _Tp, size_t _Align>
        -: 1042:struct __find_pod<__type_list<_Hp, _Tp>, _Align>
        -: 1043:{
        -: 1044:    typedef typename conditional<
        -: 1045:                             _Align == _Hp::value,
        -: 1046:                             typename _Hp::type,
        -: 1047:                             typename __find_pod<_Tp, _Align>::type
        -: 1048:                         >::type type;
        -: 1049:};
        -: 1050:
        -: 1051:template <class _TL, size_t _Len> struct __find_max_align;
        -: 1052:
        -: 1053:template <class _Hp, size_t _Len>
        -: 1054:struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};
        -: 1055:
        -: 1056:template <size_t _Len, size_t _A1, size_t _A2>
        -: 1057:struct __select_align
        -: 1058:{
        -: 1059:private:
        -: 1060:    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
        -: 1061:    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
        -: 1062:public:
        -: 1063:    static const size_t value = _Len < __max ? __min : __max;
        -: 1064:};
        -: 1065:
        -: 1066:template <class _Hp, class _Tp, size_t _Len>
        -: 1067:struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
        -: 1068:    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};
        -: 1069:
        -: 1070:template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
        -: 1071:struct _LIBCPP_TYPE_VIS_ONLY aligned_storage
        -: 1072:{
        -: 1073:    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
        -: 1074:    static_assert(!is_void<_Aligner>::value, "");
        -: 1075:    union type
        -: 1076:    {
        -: 1077:        _Aligner __align;
        -: 1078:        unsigned char __data[_Len];
        -: 1079:    };
        -: 1080:};
        -: 1081:
        -: 1082:#if _LIBCPP_STD_VER > 11
        -: 1083:template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
        -: 1084:    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
        -: 1085:#endif
        -: 1086:
        -: 1087:#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \
        -: 1088:template <size_t _Len>\
        -: 1089:struct _LIBCPP_TYPE_VIS_ONLY aligned_storage<_Len, n>\
        -: 1090:{\
        -: 1091:    struct _ALIGNAS(n) type\
        -: 1092:    {\
        -: 1093:        unsigned char __lx[_Len];\
        -: 1094:    };\
        -: 1095:}
        -: 1096:
        -: 1097:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);
        -: 1098:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);
        -: 1099:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);
        -: 1100:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);
        -: 1101:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);
        -: 1102:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);
        -: 1103:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);
        -: 1104:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);
        -: 1105:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);
        -: 1106:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);
        -: 1107:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);
        -: 1108:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);
        -: 1109:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);
        -: 1110:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);
        -: 1111:// MSDN says that MSVC does not support alignment beyond 8192 (=0x2000)
        -: 1112:#if !defined(_LIBCPP_MSVC)
        -: 1113:_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);
        -: 1114:#endif // !_LIBCPP_MSVC
        -: 1115:
        -: 1116:#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION
        -: 1117:
        -: 1118:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 1119:
        -: 1120:// aligned_union
        -: 1121:
        -: 1122:template <size_t _I0, size_t ..._In>
        -: 1123:struct __static_max;
        -: 1124:
        -: 1125:template <size_t _I0>
        -: 1126:struct __static_max<_I0>
        -: 1127:{
        -: 1128:    static const size_t value = _I0;
        -: 1129:};
        -: 1130:
        -: 1131:template <size_t _I0, size_t _I1, size_t ..._In>
        -: 1132:struct __static_max<_I0, _I1, _In...>
        -: 1133:{
        -: 1134:    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :
        -: 1135:                                             __static_max<_I1, _In...>::value;
        -: 1136:};
        -: 1137:
        -: 1138:template <size_t _Len, class _Type0, class ..._Types>
        -: 1139:struct aligned_union
        -: 1140:{
        -: 1141:    static const size_t alignment_value = __static_max<__alignof__(_Type0),
        -: 1142:                                                       __alignof__(_Types)...>::value;
        -: 1143:    static const size_t __len = __static_max<_Len, sizeof(_Type0),
        -: 1144:                                             sizeof(_Types)...>::value;
        -: 1145:    typedef typename aligned_storage<__len, alignment_value>::type type;
        -: 1146:};
        -: 1147:
        -: 1148:#if _LIBCPP_STD_VER > 11
        -: 1149:template <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
        -: 1150:#endif
        -: 1151:
        -: 1152:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 1153:
        -: 1154:// __promote
        -: 1155:
        -: 1156:template <class _A1, class _A2 = void, class _A3 = void,
        -: 1157:          bool = (is_arithmetic<_A1>::value || is_void<_A1>::value) &&
        -: 1158:                 (is_arithmetic<_A2>::value || is_void<_A2>::value) &&
        -: 1159:                 (is_arithmetic<_A3>::value || is_void<_A3>::value)>
        -: 1160:class __promote {};
        -: 1161:
        -: 1162:template <class _A1, class _A2, class _A3>
        -: 1163:class __promote<_A1, _A2, _A3, true>
        -: 1164:{
        -: 1165:private:
        -: 1166:    typedef typename __promote<_A1>::type __type1;
        -: 1167:    typedef typename __promote<_A2>::type __type2;
        -: 1168:    typedef typename __promote<_A3>::type __type3;
        -: 1169:public:
        -: 1170:    typedef decltype(__type1() + __type2() + __type3()) type;
        -: 1171:};
        -: 1172:
        -: 1173:template <class _A1, class _A2>
        -: 1174:class __promote<_A1, _A2, void, true>
        -: 1175:{
        -: 1176:private:
        -: 1177:    typedef typename __promote<_A1>::type __type1;
        -: 1178:    typedef typename __promote<_A2>::type __type2;
        -: 1179:public:
        -: 1180:    typedef decltype(__type1() + __type2()) type;
        -: 1181:};
        -: 1182:
        -: 1183:template <class _A1>
        -: 1184:class __promote<_A1, void, void, true>
        -: 1185:{
        -: 1186:public:
        -: 1187:    typedef typename conditional<is_arithmetic<_A1>::value,
        -: 1188:                     typename conditional<is_integral<_A1>::value, double, _A1>::type,
        -: 1189:                     void
        -: 1190:            >::type type;
        -: 1191:};
        -: 1192:
        -: 1193:#ifdef _LIBCPP_STORE_AS_OPTIMIZATION
        -: 1194:
        -: 1195:// __transform
        -: 1196:
        -: 1197:template <class _Tp, size_t = sizeof(_Tp), bool = is_scalar<_Tp>::value> struct __transform {typedef _Tp type;};
        -: 1198:template <class _Tp> struct __transform<_Tp, 1, true> {typedef unsigned char      type;};
        -: 1199:template <class _Tp> struct __transform<_Tp, 2, true> {typedef unsigned short     type;};
        -: 1200:template <class _Tp> struct __transform<_Tp, 4, true> {typedef unsigned int       type;};
        -: 1201:template <class _Tp> struct __transform<_Tp, 8, true> {typedef unsigned long long type;};
        -: 1202:
        -: 1203:#endif  // _LIBCPP_STORE_AS_OPTIMIZATION
        -: 1204:
        -: 1205:// make_signed / make_unsigned
        -: 1206:
        -: 1207:typedef
        -: 1208:    __type_list<signed char,
        -: 1209:    __type_list<signed short,
        -: 1210:    __type_list<signed int,
        -: 1211:    __type_list<signed long,
        -: 1212:    __type_list<signed long long,
        -: 1213:    __nat
        -: 1214:    > > > > > __signed_types;
        -: 1215:
        -: 1216:typedef
        -: 1217:    __type_list<unsigned char,
        -: 1218:    __type_list<unsigned short,
        -: 1219:    __type_list<unsigned int,
        -: 1220:    __type_list<unsigned long,
        -: 1221:    __type_list<unsigned long long,
        -: 1222:    __nat
        -: 1223:    > > > > > __unsigned_types;
        -: 1224:
        -: 1225:template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;
        -: 1226:
        -: 1227:template <class _Hp, class _Tp, size_t _Size>
        -: 1228:struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
        -: 1229:{
        -: 1230:    typedef _Hp type;
        -: 1231:};
        -: 1232:
        -: 1233:template <class _Hp, class _Tp, size_t _Size>
        -: 1234:struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
        -: 1235:{
        -: 1236:    typedef typename __find_first<_Tp, _Size>::type type;
        -: 1237:};
        -: 1238:
        -: 1239:template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
        -: 1240:                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
        -: 1241:struct __apply_cv
        -: 1242:{
        -: 1243:    typedef _Up type;
        -: 1244:};
        -: 1245:
        -: 1246:template <class _Tp, class _Up>
        -: 1247:struct __apply_cv<_Tp, _Up, true, false>
        -: 1248:{
        -: 1249:    typedef const _Up type;
        -: 1250:};
        -: 1251:
        -: 1252:template <class _Tp, class _Up>
        -: 1253:struct __apply_cv<_Tp, _Up, false, true>
        -: 1254:{
        -: 1255:    typedef volatile _Up type;
        -: 1256:};
        -: 1257:
        -: 1258:template <class _Tp, class _Up>
        -: 1259:struct __apply_cv<_Tp, _Up, true, true>
        -: 1260:{
        -: 1261:    typedef const volatile _Up type;
        -: 1262:};
        -: 1263:
        -: 1264:template <class _Tp, class _Up>
        -: 1265:struct __apply_cv<_Tp&, _Up, false, false>
        -: 1266:{
        -: 1267:    typedef _Up& type;
        -: 1268:};
        -: 1269:
        -: 1270:template <class _Tp, class _Up>
        -: 1271:struct __apply_cv<_Tp&, _Up, true, false>
        -: 1272:{
        -: 1273:    typedef const _Up& type;
        -: 1274:};
        -: 1275:
        -: 1276:template <class _Tp, class _Up>
        -: 1277:struct __apply_cv<_Tp&, _Up, false, true>
        -: 1278:{
        -: 1279:    typedef volatile _Up& type;
        -: 1280:};
        -: 1281:
        -: 1282:template <class _Tp, class _Up>
        -: 1283:struct __apply_cv<_Tp&, _Up, true, true>
        -: 1284:{
        -: 1285:    typedef const volatile _Up& type;
        -: 1286:};
        -: 1287:
        -: 1288:template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
        -: 1289:struct __make_signed {};
        -: 1290:
        -: 1291:template <class _Tp>
        -: 1292:struct __make_signed<_Tp, true>
        -: 1293:{
        -: 1294:    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
        -: 1295:};
        -: 1296:
        -: 1297:template <> struct __make_signed<bool,               true> {};
        -: 1298:template <> struct __make_signed<  signed short,     true> {typedef short     type;};
        -: 1299:template <> struct __make_signed<unsigned short,     true> {typedef short     type;};
        -: 1300:template <> struct __make_signed<  signed int,       true> {typedef int       type;};
        -: 1301:template <> struct __make_signed<unsigned int,       true> {typedef int       type;};
        -: 1302:template <> struct __make_signed<  signed long,      true> {typedef long      type;};
        -: 1303:template <> struct __make_signed<unsigned long,      true> {typedef long      type;};
        -: 1304:template <> struct __make_signed<  signed long long, true> {typedef long long type;};
        -: 1305:template <> struct __make_signed<unsigned long long, true> {typedef long long type;};
        -: 1306:
        -: 1307:template <class _Tp>
        -: 1308:struct _LIBCPP_TYPE_VIS_ONLY make_signed
        -: 1309:{
        -: 1310:    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
        -: 1311:};
        -: 1312:
        -: 1313:#if _LIBCPP_STD_VER > 11
        -: 1314:template <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;
        -: 1315:#endif
        -: 1316:
        -: 1317:template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
        -: 1318:struct __make_unsigned {};
        -: 1319:
        -: 1320:template <class _Tp>
        -: 1321:struct __make_unsigned<_Tp, true>
        -: 1322:{
        -: 1323:    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
        -: 1324:};
        -: 1325:
        -: 1326:template <> struct __make_unsigned<bool,               true> {};
        -: 1327:template <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};
        -: 1328:template <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};
        -: 1329:template <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};
        -: 1330:template <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};
        -: 1331:template <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};
        -: 1332:template <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};
        -: 1333:template <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};
        -: 1334:template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};
        -: 1335:
        -: 1336:template <class _Tp>
        -: 1337:struct _LIBCPP_TYPE_VIS_ONLY make_unsigned
        -: 1338:{
        -: 1339:    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
        -: 1340:};
        -: 1341:
        -: 1342:#if _LIBCPP_STD_VER > 11
        -: 1343:template <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;
        -: 1344:#endif
        -: 1345:
        -: 1346:#ifdef _LIBCPP_HAS_NO_VARIADICS
        -: 1347:
        -: 1348:template <class _Tp, class _Up = void, class V = void>
        -: 1349:struct _LIBCPP_TYPE_VIS_ONLY common_type
        -: 1350:{
        -: 1351:public:
        -: 1352:    typedef typename common_type<typename common_type<_Tp, _Up>::type, V>::type type;
        -: 1353:};
        -: 1354:
        -: 1355:template <class _Tp>
        -: 1356:struct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, void, void>
        -: 1357:{
        -: 1358:public:
        -: 1359:    typedef _Tp type;
        -: 1360:};
        -: 1361:
        -: 1362:template <class _Tp, class _Up>
        -: 1363:struct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, void>
        -: 1364:{
        -: 1365:private:
        -: 1366:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1367:    static _Tp&& __t();
        -: 1368:    static _Up&& __u();
        -: 1369:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1370:    static _Tp __t();
        -: 1371:    static _Up __u();
        -: 1372:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1373:public:
        -: 1374:    typedef typename remove_reference<decltype(true ? __t() : __u())>::type type;
        -: 1375:};
        -: 1376:
        -: 1377:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 1378:
        -: 1379:template <class ..._Tp> struct common_type;
        -: 1380:
        -: 1381:template <class _Tp>
        -: 1382:struct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp>
        -: 1383:{
        -: 1384:    typedef typename decay<_Tp>::type type;
        -: 1385:};
        -: 1386:
        -: 1387:template <class _Tp, class _Up>
        -: 1388:struct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up>
        -: 1389:{
        -: 1390:private:
        -: 1391:    static _Tp&& __t();
        -: 1392:    static _Up&& __u();
        -: 1393:    static bool __f();
        -: 1394:public:
        -: 1395:    typedef typename decay<decltype(__f() ? __t() : __u())>::type type;
        -: 1396:};
        -: 1397:
        -: 1398:template <class _Tp, class _Up, class ..._Vp>
        -: 1399:struct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, _Vp...>
        -: 1400:{
        -: 1401:    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;
        -: 1402:};
        -: 1403:
        -: 1404:#if _LIBCPP_STD_VER > 11
        -: 1405:template <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;
        -: 1406:#endif
        -: 1407:
        -: 1408:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 1409:
        -: 1410:// is_assignable
        -: 1411:
        -: 1412:template<typename, typename T> struct __select_2nd { typedef T type; };
        -: 1413:
        -: 1414:template <class _Tp, class _Arg>
        -: 1415:typename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type
        -: 1416:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1417:__is_assignable_test(_Tp&&, _Arg&&);
        -: 1418:#else
        -: 1419:__is_assignable_test(_Tp, _Arg&);
        -: 1420:#endif
        -: 1421:
        -: 1422:template <class _Arg>
        -: 1423:false_type
        -: 1424:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1425:__is_assignable_test(__any, _Arg&&);
        -: 1426:#else
        -: 1427:__is_assignable_test(__any, _Arg&);
        -: 1428:#endif
        -: 1429:
        -: 1430:template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
        -: 1431:struct __is_assignable_imp
        -: 1432:    : public common_type
        -: 1433:        <
        -: 1434:            decltype(__is_assignable_test(declval<_Tp>(), declval<_Arg>()))
        -: 1435:        >::type {};
        -: 1436:
        -: 1437:template <class _Tp, class _Arg>
        -: 1438:struct __is_assignable_imp<_Tp, _Arg, true>
        -: 1439:    : public false_type
        -: 1440:{
        -: 1441:};
        -: 1442:
        -: 1443:template <class _Tp, class _Arg>
        -: 1444:struct is_assignable
        -: 1445:    : public __is_assignable_imp<_Tp, _Arg> {};
        -: 1446:
        -: 1447:// is_copy_assignable
        -: 1448:
        -: 1449:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_copy_assignable
        -: 1450:    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 1451:                     const typename add_lvalue_reference<_Tp>::type> {};
        -: 1452:
        -: 1453:// is_move_assignable
        -: 1454:
        -: 1455:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_move_assignable
        -: 1456:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1457:    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 1458:                     const typename add_rvalue_reference<_Tp>::type> {};
        -: 1459:#else
        -: 1460:    : public is_copy_assignable<_Tp> {};
        -: 1461:#endif
        -: 1462:
        -: 1463:// is_destructible
        -: 1464:
        -: 1465:template <class _Tp>
        -: 1466:struct __destructible_test
        -: 1467:{
        -: 1468:    _Tp __t;
        -: 1469:};
        -: 1470:
        -: 1471:template <class _Tp>
        -: 1472:decltype((_VSTD::declval<__destructible_test<_Tp> >().~__destructible_test<_Tp>(), true_type()))
        -: 1473:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1474:__is_destructible_test(_Tp&&);
        -: 1475:#else
        -: 1476:__is_destructible_test(_Tp&);
        -: 1477:#endif
        -: 1478:
        -: 1479:false_type
        -: 1480:__is_destructible_test(__any);
        -: 1481:
        -: 1482:template <class _Tp, bool = is_void<_Tp>::value || is_abstract<_Tp>::value
        -: 1483:                                                || is_function<_Tp>::value>
        -: 1484:struct __destructible_imp
        -: 1485:    : public common_type
        -: 1486:        <
        -: 1487:            decltype(__is_destructible_test(declval<_Tp>()))
        -: 1488:        >::type {};
        -: 1489:
        -: 1490:template <class _Tp>
        -: 1491:struct __destructible_imp<_Tp, true>
        -: 1492:    : public false_type {};
        -: 1493:
        -: 1494:template <class _Tp>
        -: 1495:struct is_destructible
        -: 1496:    : public __destructible_imp<_Tp> {};
        -: 1497:
        -: 1498:template <class _Tp>
        -: 1499:struct is_destructible<_Tp[]>
        -: 1500:    : public false_type {};
        -: 1501:
        -: 1502:// move
        -: 1503:
        -: 1504:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1505:
        -: 1506:template <class _Tp>
        -: 1507:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -: 1508:typename remove_reference<_Tp>::type&&
        -: 1509:move(_Tp&& __t) _NOEXCEPT
        -: 1510:{
        -: 1511:    typedef typename remove_reference<_Tp>::type _Up;
        -: 1512:    return static_cast<_Up&&>(__t);
        -: 1513:}
        -: 1514:
        -: 1515:template <class _Tp>
        -: 1516:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -: 1517:_Tp&&
        -: 1518:forward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT
        -: 1519:{
        -: 1520:    return static_cast<_Tp&&>(__t);
        -: 1521:}
        -: 1522:
        -: 1523:template <class _Tp>
        -: 1524:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11
        -: 1525:_Tp&&
        -: 1526:forward(typename std::remove_reference<_Tp>::type&& __t) _NOEXCEPT
        -: 1527:{
        -: 1528:    static_assert(!std::is_lvalue_reference<_Tp>::value,
        -: 1529:                  "Can not forward an rvalue as an lvalue.");
        -: 1530:    return static_cast<_Tp&&>(__t);
        -: 1531:}
        -: 1532:
        -: 1533:#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1534:
        -: 1535:template <class _Tp>
        -: 1536:inline _LIBCPP_INLINE_VISIBILITY
        -: 1537:_Tp&
    #####: 1538:move(_Tp& __t)
        -: 1539:{
    #####: 1540:    return __t;
        -: 1541:}
        -: 1542:
        -: 1543:template <class _Tp>
        -: 1544:inline _LIBCPP_INLINE_VISIBILITY
        -: 1545:const _Tp&
        -: 1546:move(const _Tp& __t)
        -: 1547:{
        -: 1548:    return __t;
        -: 1549:}
        -: 1550:
        -: 1551:template <class _Tp>
        -: 1552:inline _LIBCPP_INLINE_VISIBILITY
        -: 1553:_Tp&
    #####: 1554:forward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT
        -: 1555:{
    #####: 1556:    return __t;
        -: 1557:}
        -: 1558:
        -: 1559:
        -: 1560:template <class _Tp>
        -: 1561:class __rv
        -: 1562:{
        -: 1563:    typedef typename remove_reference<_Tp>::type _Trr;
        -: 1564:    _Trr& t_;
        -: 1565:public:
        -: 1566:    _LIBCPP_INLINE_VISIBILITY
        -: 1567:    _Trr* operator->() {return &t_;}
        -: 1568:    _LIBCPP_INLINE_VISIBILITY
        -: 1569:    explicit __rv(_Trr& __t) : t_(__t) {}
        -: 1570:};
        -: 1571:
        -: 1572:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1573:
        -: 1574:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 1575:
        -: 1576:template <class _Tp>
        -: 1577:inline _LIBCPP_INLINE_VISIBILITY
        -: 1578:typename decay<_Tp>::type
        -: 1579:__decay_copy(_Tp&& __t)
        -: 1580:{
        -: 1581:    return _VSTD::forward<_Tp>(__t);
        -: 1582:}
        -: 1583:
        -: 1584:#else
        -: 1585:
        -: 1586:template <class _Tp>
        -: 1587:inline _LIBCPP_INLINE_VISIBILITY
        -: 1588:typename decay<_Tp>::type
        -: 1589:__decay_copy(const _Tp& __t)
        -: 1590:{
        -: 1591:    return _VSTD::forward<_Tp>(__t);
        -: 1592:}
        -: 1593:
        -: 1594:#endif
        -: 1595:
        -: 1596:template <class _MP, bool _IsMemberFuctionPtr, bool _IsMemberObjectPtr>
        -: 1597:struct __member_pointer_traits_imp
        -: 1598:{
        -: 1599:};
        -: 1600:
        -: 1601:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 1602:
        -: 1603:template <class _Rp, class _Class, class ..._Param>
        -: 1604:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>
        -: 1605:{
        -: 1606:    typedef _Class _ClassType;
        -: 1607:    typedef _Rp _ReturnType;
        -: 1608:};
        -: 1609:
        -: 1610:template <class _Rp, class _Class, class ..._Param>
        -: 1611:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>
        -: 1612:{
        -: 1613:    typedef _Class const _ClassType;
        -: 1614:    typedef _Rp _ReturnType;
        -: 1615:};
        -: 1616:
        -: 1617:template <class _Rp, class _Class, class ..._Param>
        -: 1618:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>
        -: 1619:{
        -: 1620:    typedef _Class volatile _ClassType;
        -: 1621:    typedef _Rp _ReturnType;
        -: 1622:};
        -: 1623:
        -: 1624:template <class _Rp, class _Class, class ..._Param>
        -: 1625:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>
        -: 1626:{
        -: 1627:    typedef _Class const volatile _ClassType;
        -: 1628:    typedef _Rp _ReturnType;
        -: 1629:};
        -: 1630:
        -: 1631:#if __has_feature(cxx_reference_qualified_functions)
        -: 1632:
        -: 1633:template <class _Rp, class _Class, class ..._Param>
        -: 1634:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>
        -: 1635:{
        -: 1636:    typedef _Class& _ClassType;
        -: 1637:    typedef _Rp _ReturnType;
        -: 1638:};
        -: 1639:
        -: 1640:template <class _Rp, class _Class, class ..._Param>
        -: 1641:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>
        -: 1642:{
        -: 1643:    typedef _Class const& _ClassType;
        -: 1644:    typedef _Rp _ReturnType;
        -: 1645:};
        -: 1646:
        -: 1647:template <class _Rp, class _Class, class ..._Param>
        -: 1648:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>
        -: 1649:{
        -: 1650:    typedef _Class volatile& _ClassType;
        -: 1651:    typedef _Rp _ReturnType;
        -: 1652:};
        -: 1653:
        -: 1654:template <class _Rp, class _Class, class ..._Param>
        -: 1655:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>
        -: 1656:{
        -: 1657:    typedef _Class const volatile& _ClassType;
        -: 1658:    typedef _Rp _ReturnType;
        -: 1659:};
        -: 1660:
        -: 1661:template <class _Rp, class _Class, class ..._Param>
        -: 1662:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>
        -: 1663:{
        -: 1664:    typedef _Class&& _ClassType;
        -: 1665:    typedef _Rp _ReturnType;
        -: 1666:};
        -: 1667:
        -: 1668:template <class _Rp, class _Class, class ..._Param>
        -: 1669:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>
        -: 1670:{
        -: 1671:    typedef _Class const&& _ClassType;
        -: 1672:    typedef _Rp _ReturnType;
        -: 1673:};
        -: 1674:
        -: 1675:template <class _Rp, class _Class, class ..._Param>
        -: 1676:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>
        -: 1677:{
        -: 1678:    typedef _Class volatile&& _ClassType;
        -: 1679:    typedef _Rp _ReturnType;
        -: 1680:};
        -: 1681:
        -: 1682:template <class _Rp, class _Class, class ..._Param>
        -: 1683:struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>
        -: 1684:{
        -: 1685:    typedef _Class const volatile&& _ClassType;
        -: 1686:    typedef _Rp _ReturnType;
        -: 1687:};
        -: 1688:
        -: 1689:#endif  // __has_feature(cxx_reference_qualified_functions)
        -: 1690:
        -: 1691:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 1692:
        -: 1693:template <class _Rp, class _Class>
        -: 1694:struct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>
        -: 1695:{
        -: 1696:    typedef _Class _ClassType;
        -: 1697:    typedef _Rp _ReturnType;
        -: 1698:};
        -: 1699:
        -: 1700:template <class _Rp, class _Class, class _P0>
        -: 1701:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>
        -: 1702:{
        -: 1703:    typedef _Class _ClassType;
        -: 1704:    typedef _Rp _ReturnType;
        -: 1705:};
        -: 1706:
        -: 1707:template <class _Rp, class _Class, class _P0, class _P1>
        -: 1708:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>
        -: 1709:{
        -: 1710:    typedef _Class _ClassType;
        -: 1711:    typedef _Rp _ReturnType;
        -: 1712:};
        -: 1713:
        -: 1714:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 1715:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>
        -: 1716:{
        -: 1717:    typedef _Class _ClassType;
        -: 1718:    typedef _Rp _ReturnType;
        -: 1719:};
        -: 1720:
        -: 1721:template <class _Rp, class _Class>
        -: 1722:struct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>
        -: 1723:{
        -: 1724:    typedef _Class const _ClassType;
        -: 1725:    typedef _Rp _ReturnType;
        -: 1726:};
        -: 1727:
        -: 1728:template <class _Rp, class _Class, class _P0>
        -: 1729:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>
        -: 1730:{
        -: 1731:    typedef _Class const _ClassType;
        -: 1732:    typedef _Rp _ReturnType;
        -: 1733:};
        -: 1734:
        -: 1735:template <class _Rp, class _Class, class _P0, class _P1>
        -: 1736:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>
        -: 1737:{
        -: 1738:    typedef _Class const _ClassType;
        -: 1739:    typedef _Rp _ReturnType;
        -: 1740:};
        -: 1741:
        -: 1742:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 1743:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>
        -: 1744:{
        -: 1745:    typedef _Class const _ClassType;
        -: 1746:    typedef _Rp _ReturnType;
        -: 1747:};
        -: 1748:
        -: 1749:template <class _Rp, class _Class>
        -: 1750:struct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>
        -: 1751:{
        -: 1752:    typedef _Class volatile _ClassType;
        -: 1753:    typedef _Rp _ReturnType;
        -: 1754:};
        -: 1755:
        -: 1756:template <class _Rp, class _Class, class _P0>
        -: 1757:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>
        -: 1758:{
        -: 1759:    typedef _Class volatile _ClassType;
        -: 1760:    typedef _Rp _ReturnType;
        -: 1761:};
        -: 1762:
        -: 1763:template <class _Rp, class _Class, class _P0, class _P1>
        -: 1764:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>
        -: 1765:{
        -: 1766:    typedef _Class volatile _ClassType;
        -: 1767:    typedef _Rp _ReturnType;
        -: 1768:};
        -: 1769:
        -: 1770:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 1771:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>
        -: 1772:{
        -: 1773:    typedef _Class volatile _ClassType;
        -: 1774:    typedef _Rp _ReturnType;
        -: 1775:};
        -: 1776:
        -: 1777:template <class _Rp, class _Class>
        -: 1778:struct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>
        -: 1779:{
        -: 1780:    typedef _Class const volatile _ClassType;
        -: 1781:    typedef _Rp _ReturnType;
        -: 1782:};
        -: 1783:
        -: 1784:template <class _Rp, class _Class, class _P0>
        -: 1785:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>
        -: 1786:{
        -: 1787:    typedef _Class const volatile _ClassType;
        -: 1788:    typedef _Rp _ReturnType;
        -: 1789:};
        -: 1790:
        -: 1791:template <class _Rp, class _Class, class _P0, class _P1>
        -: 1792:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>
        -: 1793:{
        -: 1794:    typedef _Class const volatile _ClassType;
        -: 1795:    typedef _Rp _ReturnType;
        -: 1796:};
        -: 1797:
        -: 1798:template <class _Rp, class _Class, class _P0, class _P1, class _P2>
        -: 1799:struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>
        -: 1800:{
        -: 1801:    typedef _Class const volatile _ClassType;
        -: 1802:    typedef _Rp _ReturnType;
        -: 1803:};
        -: 1804:
        -: 1805:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 1806:
        -: 1807:template <class _Rp, class _Class>
        -: 1808:struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
        -: 1809:{
        -: 1810:    typedef _Class _ClassType;
        -: 1811:    typedef _Rp _ReturnType;
        -: 1812:};
        -: 1813:
        -: 1814:template <class _MP>
        -: 1815:struct __member_pointer_traits
        -: 1816:    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
        -: 1817:                    is_member_function_pointer<_MP>::value,
        -: 1818:                    is_member_object_pointer<_MP>::value>
        -: 1819:{
        -: 1820://     typedef ... _ClassType;
        -: 1821://     typedef ... _ReturnType;
        -: 1822:};
        -: 1823:
        -: 1824:// result_of
        -: 1825:
        -: 1826:template <class _Callable> class result_of;
        -: 1827:
        -: 1828:#ifdef _LIBCPP_HAS_NO_VARIADICS
        -: 1829:
        -: 1830:template <class _Fn, bool, bool>
        -: 1831:class __result_of
        -: 1832:{
        -: 1833:};
        -: 1834:
        -: 1835:template <class _Fn>
        -: 1836:class __result_of<_Fn(), true, false>
        -: 1837:{
        -: 1838:public:
        -: 1839:    typedef decltype(declval<_Fn>()()) type;
        -: 1840:};
        -: 1841:
        -: 1842:template <class _Fn, class _A0>
        -: 1843:class __result_of<_Fn(_A0), true, false>
        -: 1844:{
        -: 1845:public:
        -: 1846:    typedef decltype(declval<_Fn>()(declval<_A0>())) type;
        -: 1847:};
        -: 1848:
        -: 1849:template <class _Fn, class _A0, class _A1>
        -: 1850:class __result_of<_Fn(_A0, _A1), true, false>
        -: 1851:{
        -: 1852:public:
        -: 1853:    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;
        -: 1854:};
        -: 1855:
        -: 1856:template <class _Fn, class _A0, class _A1, class _A2>
        -: 1857:class __result_of<_Fn(_A0, _A1, _A2), true, false>
        -: 1858:{
        -: 1859:public:
        -: 1860:    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;
        -: 1861:};
        -: 1862:
        -: 1863:template <class _MP, class _Tp, bool _IsMemberFunctionPtr>
        -: 1864:struct __result_of_mp;
        -: 1865:
        -: 1866:// member function pointer
        -: 1867:
        -: 1868:template <class _MP, class _Tp>
        -: 1869:struct __result_of_mp<_MP, _Tp, true>
        -: 1870:    : public common_type<typename __member_pointer_traits<_MP>::_ReturnType>
        -: 1871:{
        -: 1872:};
        -: 1873:
        -: 1874:// member data pointer
        -: 1875:
        -: 1876:template <class _MP, class _Tp, bool>
        -: 1877:struct __result_of_mdp;
        -: 1878:
        -: 1879:template <class _Rp, class _Class, class _Tp>
        -: 1880:struct __result_of_mdp<_Rp _Class::*, _Tp, false>
        -: 1881:{
        -: 1882:    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;
        -: 1883:};
        -: 1884:
        -: 1885:template <class _Rp, class _Class, class _Tp>
        -: 1886:struct __result_of_mdp<_Rp _Class::*, _Tp, true>
        -: 1887:{
        -: 1888:    typedef typename __apply_cv<_Tp, _Rp>::type& type;
        -: 1889:};
        -: 1890:
        -: 1891:template <class _Rp, class _Class, class _Tp>
        -: 1892:struct __result_of_mp<_Rp _Class::*, _Tp, false>
        -: 1893:    : public __result_of_mdp<_Rp _Class::*, _Tp,
        -: 1894:            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>
        -: 1895:{
        -: 1896:};
        -: 1897:
        -: 1898:
        -: 1899:
        -: 1900:template <class _Fn, class _Tp>
        -: 1901:class __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer
        -: 1902:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 1903:                            _Tp,
        -: 1904:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 1905:{
        -: 1906:};
        -: 1907:
        -: 1908:template <class _Fn, class _Tp, class _A0>
        -: 1909:class __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer
        -: 1910:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 1911:                            _Tp,
        -: 1912:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 1913:{
        -: 1914:};
        -: 1915:
        -: 1916:template <class _Fn, class _Tp, class _A0, class _A1>
        -: 1917:class __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer
        -: 1918:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 1919:                            _Tp,
        -: 1920:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 1921:{
        -: 1922:};
        -: 1923:
        -: 1924:template <class _Fn, class _Tp, class _A0, class _A1, class _A2>
        -: 1925:class __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer
        -: 1926:    : public __result_of_mp<typename remove_reference<_Fn>::type,
        -: 1927:                            _Tp,
        -: 1928:                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
        -: 1929:{
        -: 1930:};
        -: 1931:
        -: 1932:// result_of
        -: 1933:
        -: 1934:template <class _Fn>
        -: 1935:class _LIBCPP_TYPE_VIS_ONLY result_of<_Fn()>
        -: 1936:    : public __result_of<_Fn(),
        -: 1937:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 1938:                         is_function<typename remove_reference<_Fn>::type>::value,
        -: 1939:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 1940:                        >
        -: 1941:{
        -: 1942:};
        -: 1943:
        -: 1944:template <class _Fn, class _A0>
        -: 1945:class _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0)>
        -: 1946:    : public __result_of<_Fn(_A0),
        -: 1947:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 1948:                         is_function<typename remove_reference<_Fn>::type>::value,
        -: 1949:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 1950:                        >
        -: 1951:{
        -: 1952:};
        -: 1953:
        -: 1954:template <class _Fn, class _A0, class _A1>
        -: 1955:class _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1)>
        -: 1956:    : public __result_of<_Fn(_A0, _A1),
        -: 1957:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 1958:                         is_function<typename remove_reference<_Fn>::type>::value,
        -: 1959:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 1960:                        >
        -: 1961:{
        -: 1962:};
        -: 1963:
        -: 1964:template <class _Fn, class _A0, class _A1, class _A2>
        -: 1965:class _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1, _A2)>
        -: 1966:    : public __result_of<_Fn(_A0, _A1, _A2),
        -: 1967:                         is_class<typename remove_reference<_Fn>::type>::value ||
        -: 1968:                         is_function<typename remove_reference<_Fn>::type>::value,
        -: 1969:                         is_member_pointer<typename remove_reference<_Fn>::type>::value
        -: 1970:                        >
        -: 1971:{
        -: 1972:};
        -: 1973:
        -: 1974:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 1975:
        -: 1976:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 1977:
        -: 1978:// template <class T, class... Args> struct is_constructible;
        -: 1979:
        -: 1980://      main is_constructible test
        -: 1981:
        -: 1982:template <class _Tp, class ..._Args>
        -: 1983:typename __select_2nd<decltype(_VSTD::move(_Tp(_VSTD::declval<_Args>()...))), true_type>::type
        -: 1984:__is_constructible_test(_Tp&&, _Args&& ...);
        -: 1985:
        -: 1986:template <class ..._Args>
        -: 1987:false_type
        -: 1988:__is_constructible_test(__any, _Args&& ...);
        -: 1989:
        -: 1990:template <bool, class _Tp, class... _Args>
        -: 1991:struct __is_constructible // false, _Tp is not a scalar
        -: 1992:    : public common_type
        -: 1993:             <
        -: 1994:                 decltype(__is_constructible_test(declval<_Tp>(), declval<_Args>()...))
        -: 1995:             >::type
        -: 1996:    {};
        -: 1997:
        -: 1998://      function types are not constructible
        -: 1999:
        -: 2000:template <class _Rp, class... _A1, class... _A2>
        -: 2001:struct __is_constructible<false, _Rp(_A1...), _A2...>
        -: 2002:    : public false_type
        -: 2003:    {};
        -: 2004:
        -: 2005://      handle scalars and reference types
        -: 2006:
        -: 2007://      Scalars are default constructible, references are not
        -: 2008:
        -: 2009:template <class _Tp>
        -: 2010:struct __is_constructible<true, _Tp>
        -: 2011:    : public is_scalar<_Tp>
        -: 2012:    {};
        -: 2013:
        -: 2014://      Scalars and references are constructible from one arg if that arg is
        -: 2015://          implicitly convertible to the scalar or reference.
        -: 2016:
        -: 2017:template <class _Tp>
        -: 2018:struct __is_constructible_ref
        -: 2019:{
        -: 2020:    true_type static __lxx(_Tp);
        -: 2021:    false_type static __lxx(...);
        -: 2022:};
        -: 2023:
        -: 2024:template <class _Tp, class _A0>
        -: 2025:struct __is_constructible<true, _Tp, _A0>
        -: 2026:    : public common_type
        -: 2027:             <
        -: 2028:                 decltype(__is_constructible_ref<_Tp>::__lxx(declval<_A0>()))
        -: 2029:             >::type
        -: 2030:    {};
        -: 2031:
        -: 2032://      Scalars and references are not constructible from multiple args.
        -: 2033:
        -: 2034:template <class _Tp, class _A0, class ..._Args>
        -: 2035:struct __is_constructible<true, _Tp, _A0, _Args...>
        -: 2036:    : public false_type
        -: 2037:    {};
        -: 2038:
        -: 2039://      Treat scalars and reference types separately
        -: 2040:
        -: 2041:template <bool, class _Tp, class... _Args>
        -: 2042:struct __is_constructible_void_check
        -: 2043:    : public __is_constructible<is_scalar<_Tp>::value || is_reference<_Tp>::value,
        -: 2044:                                _Tp, _Args...>
        -: 2045:    {};
        -: 2046:
        -: 2047://      If any of T or Args is void, is_constructible should be false
        -: 2048:
        -: 2049:template <class _Tp, class... _Args>
        -: 2050:struct __is_constructible_void_check<true, _Tp, _Args...>
        -: 2051:    : public false_type
        -: 2052:    {};
        -: 2053:
        -: 2054:template <class ..._Args> struct __contains_void;
        -: 2055:
        -: 2056:template <> struct __contains_void<> : false_type {};
        -: 2057:
        -: 2058:template <class _A0, class ..._Args>
        -: 2059:struct __contains_void<_A0, _Args...>
        -: 2060:{
        -: 2061:    static const bool value = is_void<_A0>::value ||
        -: 2062:                              __contains_void<_Args...>::value;
        -: 2063:};
        -: 2064:
        -: 2065://      is_constructible entry point
        -: 2066:
        -: 2067:template <class _Tp, class... _Args>
        -: 2068:struct _LIBCPP_TYPE_VIS_ONLY is_constructible
        -: 2069:    : public __is_constructible_void_check<__contains_void<_Tp, _Args...>::value
        -: 2070:                                        || is_abstract<_Tp>::value,
        -: 2071:                                           _Tp, _Args...>
        -: 2072:    {};
        -: 2073:
        -: 2074://      Array types are default constructible if their element type
        -: 2075://      is default constructible
        -: 2076:
        -: 2077:template <class _Ap, size_t _Np>
        -: 2078:struct __is_constructible<false, _Ap[_Np]>
        -: 2079:    : public is_constructible<typename remove_all_extents<_Ap>::type>
        -: 2080:    {};
        -: 2081:
        -: 2082://      Otherwise array types are not constructible by this syntax
        -: 2083:
        -: 2084:template <class _Ap, size_t _Np, class ..._Args>
        -: 2085:struct __is_constructible<false, _Ap[_Np], _Args...>
        -: 2086:    : public false_type
        -: 2087:    {};
        -: 2088:
        -: 2089://      Incomplete array types are not constructible
        -: 2090:
        -: 2091:template <class _Ap, class ..._Args>
        -: 2092:struct __is_constructible<false, _Ap[], _Args...>
        -: 2093:    : public false_type
        -: 2094:    {};
        -: 2095:
        -: 2096:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 2097:
        -: 2098:// template <class T> struct is_constructible0;
        -: 2099:
        -: 2100://      main is_constructible0 test
        -: 2101:
        -: 2102:template <class _Tp>
        -: 2103:decltype((_Tp(), true_type()))
        -: 2104:__is_constructible0_test(_Tp&);
        -: 2105:
        -: 2106:false_type
        -: 2107:__is_constructible0_test(__any);
        -: 2108:
        -: 2109:template <class _Tp, class _A0>
        -: 2110:decltype((_Tp(_VSTD::declval<_A0>()), true_type()))
        -: 2111:__is_constructible1_test(_Tp&, _A0&);
        -: 2112:
        -: 2113:template <class _A0>
        -: 2114:false_type
        -: 2115:__is_constructible1_test(__any, _A0&);
        -: 2116:
        -: 2117:template <class _Tp, class _A0, class _A1>
        -: 2118:decltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))
        -: 2119:__is_constructible2_test(_Tp&, _A0&, _A1&);
        -: 2120:
        -: 2121:template <class _A0, class _A1>
        -: 2122:false_type
        -: 2123:__is_constructible2_test(__any, _A0&, _A1&);
        -: 2124:
        -: 2125:template <bool, class _Tp>
        -: 2126:struct __is_constructible0_imp // false, _Tp is not a scalar
        -: 2127:    : public common_type
        -: 2128:             <
        -: 2129:                 decltype(__is_constructible0_test(declval<_Tp&>()))
        -: 2130:             >::type
        -: 2131:    {};
        -: 2132:
        -: 2133:template <bool, class _Tp, class _A0>
        -: 2134:struct __is_constructible1_imp // false, _Tp is not a scalar
        -: 2135:    : public common_type
        -: 2136:             <
        -: 2137:                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))
        -: 2138:             >::type
        -: 2139:    {};
        -: 2140:
        -: 2141:template <bool, class _Tp, class _A0, class _A1>
        -: 2142:struct __is_constructible2_imp // false, _Tp is not a scalar
        -: 2143:    : public common_type
        -: 2144:             <
        -: 2145:                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))
        -: 2146:             >::type
        -: 2147:    {};
        -: 2148:
        -: 2149://      handle scalars and reference types
        -: 2150:
        -: 2151://      Scalars are default constructible, references are not
        -: 2152:
        -: 2153:template <class _Tp>
        -: 2154:struct __is_constructible0_imp<true, _Tp>
        -: 2155:    : public is_scalar<_Tp>
        -: 2156:    {};
        -: 2157:
        -: 2158:template <class _Tp, class _A0>
        -: 2159:struct __is_constructible1_imp<true, _Tp, _A0>
        -: 2160:    : public is_convertible<_A0, _Tp>
        -: 2161:    {};
        -: 2162:
        -: 2163:template <class _Tp, class _A0, class _A1>
        -: 2164:struct __is_constructible2_imp<true, _Tp, _A0, _A1>
        -: 2165:    : public false_type
        -: 2166:    {};
        -: 2167:
        -: 2168://      Treat scalars and reference types separately
        -: 2169:
        -: 2170:template <bool, class _Tp>
        -: 2171:struct __is_constructible0_void_check
        -: 2172:    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
        -: 2173:                                _Tp>
        -: 2174:    {};
        -: 2175:
        -: 2176:template <bool, class _Tp, class _A0>
        -: 2177:struct __is_constructible1_void_check
        -: 2178:    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
        -: 2179:                                _Tp, _A0>
        -: 2180:    {};
        -: 2181:
        -: 2182:template <bool, class _Tp, class _A0, class _A1>
        -: 2183:struct __is_constructible2_void_check
        -: 2184:    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
        -: 2185:                                _Tp, _A0, _A1>
        -: 2186:    {};
        -: 2187:
        -: 2188://      If any of T or Args is void, is_constructible should be false
        -: 2189:
        -: 2190:template <class _Tp>
        -: 2191:struct __is_constructible0_void_check<true, _Tp>
        -: 2192:    : public false_type
        -: 2193:    {};
        -: 2194:
        -: 2195:template <class _Tp, class _A0>
        -: 2196:struct __is_constructible1_void_check<true, _Tp, _A0>
        -: 2197:    : public false_type
        -: 2198:    {};
        -: 2199:
        -: 2200:template <class _Tp, class _A0, class _A1>
        -: 2201:struct __is_constructible2_void_check<true, _Tp, _A0, _A1>
        -: 2202:    : public false_type
        -: 2203:    {};
        -: 2204:
        -: 2205://      is_constructible entry point
        -: 2206:
        -: 2207:namespace __is_construct
        -: 2208:{
        -: 2209:
        -: 2210:struct __nat {};
        -: 2211:
        -: 2212:}
        -: 2213:
        -: 2214:template <class _Tp, class _A0 = __is_construct::__nat,
        -: 2215:                     class _A1 = __is_construct::__nat>
        -: 2216:struct _LIBCPP_TYPE_VIS_ONLY is_constructible
        -: 2217:    : public __is_constructible2_void_check<is_void<_Tp>::value
        -: 2218:                                        || is_abstract<_Tp>::value
        -: 2219:                                        || is_function<_Tp>::value
        -: 2220:                                        || is_void<_A0>::value
        -: 2221:                                        || is_void<_A1>::value,
        -: 2222:                                           _Tp, _A0, _A1>
        -: 2223:    {};
        -: 2224:
        -: 2225:template <class _Tp>
        -: 2226:struct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>
        -: 2227:    : public __is_constructible0_void_check<is_void<_Tp>::value
        -: 2228:                                        || is_abstract<_Tp>::value
        -: 2229:                                        || is_function<_Tp>::value,
        -: 2230:                                           _Tp>
        -: 2231:    {};
        -: 2232:
        -: 2233:template <class _Tp, class _A0>
        -: 2234:struct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, _A0, __is_construct::__nat>
        -: 2235:    : public __is_constructible1_void_check<is_void<_Tp>::value
        -: 2236:                                        || is_abstract<_Tp>::value
        -: 2237:                                        || is_function<_Tp>::value
        -: 2238:                                        || is_void<_A0>::value,
        -: 2239:                                           _Tp, _A0>
        -: 2240:    {};
        -: 2241:
        -: 2242://      Array types are default constructible if their element type
        -: 2243://      is default constructible
        -: 2244:
        -: 2245:template <class _Ap, size_t _Np>
        -: 2246:struct __is_constructible0_imp<false, _Ap[_Np]>
        -: 2247:    : public is_constructible<typename remove_all_extents<_Ap>::type>
        -: 2248:    {};
        -: 2249:
        -: 2250:template <class _Ap, size_t _Np, class _A0>
        -: 2251:struct __is_constructible1_imp<false, _Ap[_Np], _A0>
        -: 2252:    : public false_type
        -: 2253:    {};
        -: 2254:
        -: 2255:template <class _Ap, size_t _Np, class _A0, class _A1>
        -: 2256:struct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>
        -: 2257:    : public false_type
        -: 2258:    {};
        -: 2259:
        -: 2260://      Incomplete array types are not constructible
        -: 2261:
        -: 2262:template <class _Ap>
        -: 2263:struct __is_constructible0_imp<false, _Ap[]>
        -: 2264:    : public false_type
        -: 2265:    {};
        -: 2266:
        -: 2267:template <class _Ap, class _A0>
        -: 2268:struct __is_constructible1_imp<false, _Ap[], _A0>
        -: 2269:    : public false_type
        -: 2270:    {};
        -: 2271:
        -: 2272:template <class _Ap, class _A0, class _A1>
        -: 2273:struct __is_constructible2_imp<false, _Ap[], _A0, _A1>
        -: 2274:    : public false_type
        -: 2275:    {};
        -: 2276:
        -: 2277:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 2278:
        -: 2279:// is_default_constructible
        -: 2280:
        -: 2281:template <class _Tp>
        -: 2282:struct _LIBCPP_TYPE_VIS_ONLY is_default_constructible
        -: 2283:    : public is_constructible<_Tp>
        -: 2284:    {};
        -: 2285:
        -: 2286:// is_copy_constructible
        -: 2287:
        -: 2288:template <class _Tp>
        -: 2289:struct _LIBCPP_TYPE_VIS_ONLY is_copy_constructible
        -: 2290:    : public is_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>
        -: 2291:    {};
        -: 2292:
        -: 2293:// is_move_constructible
        -: 2294:
        -: 2295:template <class _Tp>
        -: 2296:struct _LIBCPP_TYPE_VIS_ONLY is_move_constructible
        -: 2297:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2298:    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
        -: 2299:#else
        -: 2300:    : public is_copy_constructible<_Tp>
        -: 2301:#endif
        -: 2302:    {};
        -: 2303:
        -: 2304:// is_trivially_constructible
        -: 2305:
        -: 2306:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 2307:
        -: 2308:#if __has_feature(is_trivially_constructible)
        -: 2309:
        -: 2310:template <class _Tp, class... _Args>
        -: 2311:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible
        -: 2312:    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>
        -: 2313:{
        -: 2314:};
        -: 2315:
        -: 2316:#else  // !__has_feature(is_trivially_constructible)
        -: 2317:
        -: 2318:template <class _Tp, class... _Args>
        -: 2319:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible
        -: 2320:    : false_type
        -: 2321:{
        -: 2322:};
        -: 2323:
        -: 2324:template <class _Tp>
        -: 2325:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp>
        -: 2326:#if __has_feature(has_trivial_constructor) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -: 2327:    : integral_constant<bool, __has_trivial_constructor(_Tp)>
        -: 2328:#else
        -: 2329:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2330:#endif
        -: 2331:{
        -: 2332:};
        -: 2333:
        -: 2334:template <class _Tp>
        -: 2335:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2336:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&&>
        -: 2337:#else
        -: 2338:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp>
        -: 2339:#endif
        -: 2340:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2341:{
        -: 2342:};
        -: 2343:
        -: 2344:template <class _Tp>
        -: 2345:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&>
        -: 2346:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2347:{
        -: 2348:};
        -: 2349:
        -: 2350:template <class _Tp>
        -: 2351:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&>
        -: 2352:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2353:{
        -: 2354:};
        -: 2355:
        -: 2356:#endif  // !__has_feature(is_trivially_constructible)
        -: 2357:
        -: 2358:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 2359:
        -: 2360:template <class _Tp, class _A0 = __is_construct::__nat,
        -: 2361:                     class _A1 = __is_construct::__nat>
        -: 2362:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible
        -: 2363:    : false_type
        -: 2364:{
        -: 2365:};
        -: 2366:
        -: 2367:#if __has_feature(is_trivially_constructible)
        -: 2368:
        -: 2369:template <class _Tp>
        -: 2370:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,
        -: 2371:                                                       __is_construct::__nat>
        -: 2372:    : integral_constant<bool, __is_trivially_constructible(_Tp)>
        -: 2373:{
        -: 2374:};
        -: 2375:
        -: 2376:template <class _Tp>
        -: 2377:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,
        -: 2378:                                                       __is_construct::__nat>
        -: 2379:    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>
        -: 2380:{
        -: 2381:};
        -: 2382:
        -: 2383:template <class _Tp>
        -: 2384:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,
        -: 2385:                                                       __is_construct::__nat>
        -: 2386:    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>
        -: 2387:{
        -: 2388:};
        -: 2389:
        -: 2390:template <class _Tp>
        -: 2391:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,
        -: 2392:                                                       __is_construct::__nat>
        -: 2393:    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>
        -: 2394:{
        -: 2395:};
        -: 2396:
        -: 2397:#else  // !__has_feature(is_trivially_constructible)
        -: 2398:
        -: 2399:template <class _Tp>
        -: 2400:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,
        -: 2401:                                                       __is_construct::__nat>
        -: 2402:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2403:{
        -: 2404:};
        -: 2405:
        -: 2406:template <class _Tp>
        -: 2407:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,
        -: 2408:                                                       __is_construct::__nat>
        -: 2409:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2410:{
        -: 2411:};
        -: 2412:
        -: 2413:template <class _Tp>
        -: 2414:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,
        -: 2415:                                                       __is_construct::__nat>
        -: 2416:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2417:{
        -: 2418:};
        -: 2419:
        -: 2420:template <class _Tp>
        -: 2421:struct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,
        -: 2422:                                                       __is_construct::__nat>
        -: 2423:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2424:{
        -: 2425:};
        -: 2426:
        -: 2427:#endif  // !__has_feature(is_trivially_constructible)
        -: 2428:
        -: 2429:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 2430:
        -: 2431:// is_trivially_default_constructible
        -: 2432:
        -: 2433:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_default_constructible
        -: 2434:    : public is_trivially_constructible<_Tp>
        -: 2435:    {};
        -: 2436:
        -: 2437:// is_trivially_copy_constructible
        -: 2438:
        -: 2439:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_constructible
        -: 2440:    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
        -: 2441:    {};
        -: 2442:
        -: 2443:// is_trivially_move_constructible
        -: 2444:
        -: 2445:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_constructible
        -: 2446:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2447:    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
        -: 2448:#else
        -: 2449:    : public is_trivially_copy_constructible<_Tp>
        -: 2450:#endif
        -: 2451:    {};
        -: 2452:
        -: 2453:// is_trivially_assignable
        -: 2454:
        -: 2455:#if __has_feature(is_trivially_constructible)
        -: 2456:
        -: 2457:template <class _Tp, class _Arg>
        -: 2458:struct is_trivially_assignable
        -: 2459:    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
        -: 2460:{
        -: 2461:};
        -: 2462:
        -: 2463:#else  // !__has_feature(is_trivially_constructible)
        -: 2464:
        -: 2465:template <class _Tp, class _Arg>
        -: 2466:struct is_trivially_assignable
        -: 2467:    : public false_type {};
        -: 2468:
        -: 2469:template <class _Tp>
        -: 2470:struct is_trivially_assignable<_Tp&, _Tp>
        -: 2471:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 2472:
        -: 2473:template <class _Tp>
        -: 2474:struct is_trivially_assignable<_Tp&, _Tp&>
        -: 2475:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 2476:
        -: 2477:template <class _Tp>
        -: 2478:struct is_trivially_assignable<_Tp&, const _Tp&>
        -: 2479:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 2480:
        -: 2481:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2482:
        -: 2483:template <class _Tp>
        -: 2484:struct is_trivially_assignable<_Tp&, _Tp&&>
        -: 2485:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 2486:
        -: 2487:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2488:
        -: 2489:#endif  // !__has_feature(is_trivially_constructible)
        -: 2490:
        -: 2491:// is_trivially_copy_assignable
        -: 2492:
        -: 2493:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_assignable
        -: 2494:    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 2495:                               const typename add_lvalue_reference<_Tp>::type>
        -: 2496:    {};
        -: 2497:
        -: 2498:// is_trivially_move_assignable
        -: 2499:
        -: 2500:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_assignable
        -: 2501:    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 2502:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2503:                                     typename add_rvalue_reference<_Tp>::type>
        -: 2504:#else
        -: 2505:                                     typename add_lvalue_reference<_Tp>::type>
        -: 2506:#endif
        -: 2507:    {};
        -: 2508:
        -: 2509:// is_trivially_destructible
        -: 2510:
        -: 2511:#if __has_feature(has_trivial_destructor) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -: 2512:
        -: 2513:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible
        -: 2514:    : public integral_constant<bool, __has_trivial_destructor(_Tp)> {};
        -: 2515:
        -: 2516:#else  // _LIBCPP_HAS_TYPE_TRAITS
        -: 2517:
        -: 2518:template <class _Tp> struct __libcpp_trivial_destructor
        -: 2519:    : public integral_constant<bool, is_scalar<_Tp>::value ||
        -: 2520:                                     is_reference<_Tp>::value> {};
        -: 2521:
        -: 2522:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible
        -: 2523:    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};
        -: 2524:
        -: 2525:#endif  // _LIBCPP_HAS_TYPE_TRAITS
        -: 2526:
        -: 2527:// is_nothrow_constructible
        -: 2528:
        -: 2529:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 2530:
        -: 2531:#if __has_feature(cxx_noexcept)
        -: 2532:
        -: 2533:template <bool, class _Tp, class... _Args> struct __is_nothrow_constructible;
        -: 2534:
        -: 2535:template <class _Tp, class... _Args>
        -: 2536:struct __is_nothrow_constructible<true, _Tp, _Args...>
        -: 2537:    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
        -: 2538:{
        -: 2539:};
        -: 2540:
        -: 2541:template <class _Tp, class... _Args>
        -: 2542:struct __is_nothrow_constructible<false, _Tp, _Args...>
        -: 2543:    : public false_type
        -: 2544:{
        -: 2545:};
        -: 2546:
        -: 2547:template <class _Tp, class... _Args>
        -: 2548:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible
        -: 2549:    : __is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, _Tp, _Args...>
        -: 2550:{
        -: 2551:};
        -: 2552:
        -: 2553:template <class _Tp, size_t _Ns>
        -: 2554:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp[_Ns]>
        -: 2555:    : __is_nothrow_constructible<is_constructible<_Tp>::value, _Tp>
        -: 2556:{
        -: 2557:};
        -: 2558:
        -: 2559:#else  // __has_feature(cxx_noexcept)
        -: 2560:
        -: 2561:template <class _Tp, class... _Args>
        -: 2562:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible
        -: 2563:    : false_type
        -: 2564:{
        -: 2565:};
        -: 2566:
        -: 2567:template <class _Tp>
        -: 2568:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp>
        -: 2569:#if __has_feature(has_nothrow_constructor) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -: 2570:    : integral_constant<bool, __has_nothrow_constructor(_Tp)>
        -: 2571:#else
        -: 2572:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2573:#endif
        -: 2574:{
        -: 2575:};
        -: 2576:
        -: 2577:template <class _Tp>
        -: 2578:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2579:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&&>
        -: 2580:#else
        -: 2581:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp>
        -: 2582:#endif
        -: 2583:#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -: 2584:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 2585:#else
        -: 2586:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2587:#endif
        -: 2588:{
        -: 2589:};
        -: 2590:
        -: 2591:template <class _Tp>
        -: 2592:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&>
        -: 2593:#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -: 2594:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 2595:#else
        -: 2596:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2597:#endif
        -: 2598:{
        -: 2599:};
        -: 2600:
        -: 2601:template <class _Tp>
        -: 2602:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&>
        -: 2603:#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -: 2604:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 2605:#else
        -: 2606:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2607:#endif
        -: 2608:{
        -: 2609:};
        -: 2610:
        -: 2611:#endif  // __has_feature(cxx_noexcept)
        -: 2612:
        -: 2613:#else  // _LIBCPP_HAS_NO_VARIADICS
        -: 2614:
        -: 2615:template <class _Tp, class _A0 = __is_construct::__nat,
        -: 2616:                     class _A1 = __is_construct::__nat>
        -: 2617:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible
        -: 2618:    : false_type
        -: 2619:{
        -: 2620:};
        -: 2621:
        -: 2622:template <class _Tp>
        -: 2623:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, __is_construct::__nat,
        -: 2624:                                                       __is_construct::__nat>
        -: 2625:#if __has_feature(has_nothrow_constructor) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -: 2626:    : integral_constant<bool, __has_nothrow_constructor(_Tp)>
        -: 2627:#else
        -: 2628:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2629:#endif
        -: 2630:{
        -: 2631:};
        -: 2632:
        -: 2633:template <class _Tp>
        -: 2634:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp,
        -: 2635:                                                       __is_construct::__nat>
        -: 2636:#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -: 2637:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 2638:#else
        -: 2639:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2640:#endif
        -: 2641:{
        -: 2642:};
        -: 2643:
        -: 2644:template <class _Tp>
        -: 2645:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&,
        -: 2646:                                                       __is_construct::__nat>
        -: 2647:#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -: 2648:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 2649:#else
        -: 2650:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2651:#endif
        -: 2652:{
        -: 2653:};
        -: 2654:
        -: 2655:template <class _Tp>
        -: 2656:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&,
        -: 2657:                                                       __is_construct::__nat>
        -: 2658:#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -: 2659:    : integral_constant<bool, __has_nothrow_copy(_Tp)>
        -: 2660:#else
        -: 2661:    : integral_constant<bool, is_scalar<_Tp>::value>
        -: 2662:#endif
        -: 2663:{
        -: 2664:};
        -: 2665:
        -: 2666:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 2667:
        -: 2668:// is_nothrow_default_constructible
        -: 2669:
        -: 2670:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_default_constructible
        -: 2671:    : public is_nothrow_constructible<_Tp>
        -: 2672:    {};
        -: 2673:
        -: 2674:// is_nothrow_copy_constructible
        -: 2675:
        -: 2676:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_constructible
        -: 2677:    : public is_nothrow_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>
        -: 2678:    {};
        -: 2679:
        -: 2680:// is_nothrow_move_constructible
        -: 2681:
        -: 2682:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_constructible
        -: 2683:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2684:    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>
        -: 2685:#else
        -: 2686:    : public is_nothrow_copy_constructible<_Tp>
        -: 2687:#endif
        -: 2688:    {};
        -: 2689:
        -: 2690:// is_nothrow_assignable
        -: 2691:
        -: 2692:#if __has_feature(cxx_noexcept)
        -: 2693:
        -: 2694:template <bool, class _Tp, class _Arg> struct __is_nothrow_assignable;
        -: 2695:
        -: 2696:template <class _Tp, class _Arg>
        -: 2697:struct __is_nothrow_assignable<false, _Tp, _Arg>
        -: 2698:    : public false_type
        -: 2699:{
        -: 2700:};
        -: 2701:
        -: 2702:template <class _Tp, class _Arg>
        -: 2703:struct __is_nothrow_assignable<true, _Tp, _Arg>
        -: 2704:    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >
        -: 2705:{
        -: 2706:};
        -: 2707:
        -: 2708:template <class _Tp, class _Arg>
        -: 2709:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable
        -: 2710:    : public __is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>
        -: 2711:{
        -: 2712:};
        -: 2713:
        -: 2714:#else  // __has_feature(cxx_noexcept)
        -: 2715:
        -: 2716:template <class _Tp, class _Arg>
        -: 2717:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable
        -: 2718:    : public false_type {};
        -: 2719:
        -: 2720:template <class _Tp>
        -: 2721:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp>
        -: 2722:#if __has_feature(has_nothrow_assign) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -: 2723:    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
        -: 2724:#else
        -: 2725:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 2726:#endif
        -: 2727:
        -: 2728:template <class _Tp>
        -: 2729:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp&>
        -: 2730:#if __has_feature(has_nothrow_assign) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -: 2731:    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
        -: 2732:#else
        -: 2733:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 2734:#endif
        -: 2735:
        -: 2736:template <class _Tp>
        -: 2737:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, const _Tp&>
        -: 2738:#if __has_feature(has_nothrow_assign) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -: 2739:    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
        -: 2740:#else
        -: 2741:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 2742:#endif
        -: 2743:
        -: 2744:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2745:
        -: 2746:template <class _Tp>
        -: 2747:struct is_nothrow_assignable<_Tp&, _Tp&&>
        -: 2748:#if __has_feature(has_nothrow_assign) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -: 2749:    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
        -: 2750:#else
        -: 2751:    : integral_constant<bool, is_scalar<_Tp>::value> {};
        -: 2752:#endif
        -: 2753:
        -: 2754:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2755:
        -: 2756:#endif  // __has_feature(cxx_noexcept)
        -: 2757:
        -: 2758:// is_nothrow_copy_assignable
        -: 2759:
        -: 2760:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_assignable
        -: 2761:    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 2762:                               const typename add_lvalue_reference<_Tp>::type>
        -: 2763:    {};
        -: 2764:
        -: 2765:// is_nothrow_move_assignable
        -: 2766:
        -: 2767:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_assignable
        -: 2768:    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
        -: 2769:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2770:                                     typename add_rvalue_reference<_Tp>::type>
        -: 2771:#else
        -: 2772:                                     typename add_lvalue_reference<_Tp>::type>
        -: 2773:#endif
        -: 2774:    {};
        -: 2775:
        -: 2776:// is_nothrow_destructible
        -: 2777:
        -: 2778:#if __has_feature(cxx_noexcept)
        -: 2779:
        -: 2780:template <bool, class _Tp> struct __is_nothrow_destructible;
        -: 2781:
        -: 2782:template <class _Tp>
        -: 2783:struct __is_nothrow_destructible<false, _Tp>
        -: 2784:    : public false_type
        -: 2785:{
        -: 2786:};
        -: 2787:
        -: 2788:template <class _Tp>
        -: 2789:struct __is_nothrow_destructible<true, _Tp>
        -: 2790:    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >
        -: 2791:{
        -: 2792:};
        -: 2793:
        -: 2794:template <class _Tp>
        -: 2795:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible
        -: 2796:    : public __is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>
        -: 2797:{
        -: 2798:};
        -: 2799:
        -: 2800:template <class _Tp, size_t _Ns>
        -: 2801:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[_Ns]>
        -: 2802:    : public is_nothrow_destructible<_Tp>
        -: 2803:{
        -: 2804:};
        -: 2805:
        -: 2806:template <class _Tp>
        -: 2807:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&>
        -: 2808:    : public true_type
        -: 2809:{
        -: 2810:};
        -: 2811:
        -: 2812:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -: 2813:
        -: 2814:template <class _Tp>
        -: 2815:struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&&>
        -: 2816:    : public true_type
        -: 2817:{
        -: 2818:};
        -: 2819:
        -: 2820:#endif
        -: 2821:
        -: 2822:#else
        -: 2823:
        -: 2824:template <class _Tp> struct __libcpp_nothrow_destructor
        -: 2825:    : public integral_constant<bool, is_scalar<_Tp>::value ||
        -: 2826:                                     is_reference<_Tp>::value> {};
        -: 2827:
        -: 2828:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible
        -: 2829:    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};
        -: 2830:
        -: 2831:#endif
        -: 2832:
        -: 2833:// is_pod
        -: 2834:
        -: 2835:#if __has_feature(is_pod) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
        -: 2836:
        -: 2837:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod
        -: 2838:    : public integral_constant<bool, __is_pod(_Tp)> {};
        -: 2839:
        -: 2840:#else  // _LIBCPP_HAS_TYPE_TRAITS
        -: 2841:
        -: 2842:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod
        -: 2843:    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&
        -: 2844:                                     is_trivially_copy_constructible<_Tp>::value      &&
        -: 2845:                                     is_trivially_copy_assignable<_Tp>::value    &&
        -: 2846:                                     is_trivially_destructible<_Tp>::value> {};
        -: 2847:
        -: 2848:#endif  // _LIBCPP_HAS_TYPE_TRAITS
        -: 2849:
        -: 2850:// is_literal_type;
        -: 2851:
        -: 2852:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_literal_type
        -: 2853:#if __has_feature(is_literal)
        -: 2854:    : public integral_constant<bool, __is_literal(_Tp)>
        -: 2855:#else
        -: 2856:    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||
        -: 2857:                              is_reference<typename remove_all_extents<_Tp>::type>::value>
        -: 2858:#endif
        -: 2859:    {};
        -: 2860:    
        -: 2861:// is_standard_layout;
        -: 2862:
        -: 2863:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_standard_layout
        -: 2864:#if __has_feature(is_standard_layout)
        -: 2865:    : public integral_constant<bool, __is_standard_layout(_Tp)>
        -: 2866:#else
        -: 2867:    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>
        -: 2868:#endif
        -: 2869:    {};
        -: 2870:    
        -: 2871:// is_trivially_copyable;
        -: 2872:
        -: 2873:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copyable
        -: 2874:#if __has_feature(is_trivially_copyable)
        -: 2875:    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
        -: 2876:#else
        -: 2877:    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>
        -: 2878:#endif
        -: 2879:    {};
        -: 2880:    
        -: 2881:// is_trivial;
        -: 2882:
        -: 2883:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivial
        -: 2884:#if __has_feature(is_trivial)
        -: 2885:    : public integral_constant<bool, __is_trivial(_Tp)>
        -: 2886:#else
        -: 2887:    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&
        -: 2888:                                 is_trivially_default_constructible<_Tp>::value>
        -: 2889:#endif
        -: 2890:    {};
        -: 2891:
        -: 2892:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -: 2893:
        -: 2894:// Check for complete types
        -: 2895:
        -: 2896:template <class ..._Tp> struct __check_complete;
        -: 2897:
        -: 2898:template <>
        -: 2899:struct __check_complete<>
        -: 2900:{
        -: 2901:};
        -: 2902:
        -: 2903:template <class _Hp, class _T0, class ..._Tp>
        -: 2904:struct __check_complete<_Hp, _T0, _Tp...>
        -: 2905:    : private __check_complete<_Hp>,
        -: 2906:      private __check_complete<_T0, _Tp...>
        -: 2907:{
        -: 2908:};
        -: 2909:
        -: 2910:template <class _Hp>
        -: 2911:struct __check_complete<_Hp, _Hp>
        -: 2912:    : private __check_complete<_Hp>
        -: 2913:{
        -: 2914:};
        -: 2915:
        -: 2916:template <class _Tp>
        -: 2917:struct __check_complete<_Tp>
        -: 2918:{
        -: 2919:    static_assert(sizeof(_Tp) > 0, "Type must be complete.");
        -: 2920:};
        -: 2921:
        -: 2922:template <class _Tp>
        -: 2923:struct __check_complete<_Tp&>
        -: 2924:    : private __check_complete<_Tp>
        -: 2925:{
        -: 2926:};
        -: 2927:
        -: 2928:template <class _Tp>
        -: 2929:struct __check_complete<_Tp&&>
        -: 2930:    : private __check_complete<_Tp>
        -: 2931:{
        -: 2932:};
        -: 2933:
        -: 2934:template <class _Rp, class ..._Param>
        -: 2935:struct __check_complete<_Rp (*)(_Param...)>
        -: 2936:    : private __check_complete<_Rp>
        -: 2937:{
        -: 2938:};
        -: 2939:
        -: 2940:template <class ..._Param>
        -: 2941:struct __check_complete<void (*)(_Param...)>
        -: 2942:{
        -: 2943:};
        -: 2944:
        -: 2945:template <class _Rp, class ..._Param>
        -: 2946:struct __check_complete<_Rp (_Param...)>
        -: 2947:    : private __check_complete<_Rp>
        -: 2948:{
        -: 2949:};
        -: 2950:
        -: 2951:template <class ..._Param>
        -: 2952:struct __check_complete<void (_Param...)>
        -: 2953:{
        -: 2954:};
        -: 2955:
        -: 2956:template <class _Rp, class _Class, class ..._Param>
        -: 2957:struct __check_complete<_Rp (_Class::*)(_Param...)>
        -: 2958:    : private __check_complete<_Class>
        -: 2959:{
        -: 2960:};
        -: 2961:
        -: 2962:template <class _Rp, class _Class, class ..._Param>
        -: 2963:struct __check_complete<_Rp (_Class::*)(_Param...) const>
        -: 2964:    : private __check_complete<_Class>
        -: 2965:{
        -: 2966:};
        -: 2967:
        -: 2968:template <class _Rp, class _Class, class ..._Param>
        -: 2969:struct __check_complete<_Rp (_Class::*)(_Param...) volatile>
        -: 2970:    : private __check_complete<_Class>
        -: 2971:{
        -: 2972:};
        -: 2973:
        -: 2974:template <class _Rp, class _Class, class ..._Param>
        -: 2975:struct __check_complete<_Rp (_Class::*)(_Param...) const volatile>
        -: 2976:    : private __check_complete<_Class>
        -: 2977:{
        -: 2978:};
        -: 2979:
        -: 2980:#if __has_feature(cxx_reference_qualified_functions)
        -: 2981:
        -: 2982:template <class _Rp, class _Class, class ..._Param>
        -: 2983:struct __check_complete<_Rp (_Class::*)(_Param...) &>
        -: 2984:    : private __check_complete<_Class>
        -: 2985:{
        -: 2986:};
        -: 2987:
        -: 2988:template <class _Rp, class _Class, class ..._Param>
        -: 2989:struct __check_complete<_Rp (_Class::*)(_Param...) const&>
        -: 2990:    : private __check_complete<_Class>
        -: 2991:{
        -: 2992:};
        -: 2993:
        -: 2994:template <class _Rp, class _Class, class ..._Param>
        -: 2995:struct __check_complete<_Rp (_Class::*)(_Param...) volatile&>
        -: 2996:    : private __check_complete<_Class>
        -: 2997:{
        -: 2998:};
        -: 2999:
        -: 3000:template <class _Rp, class _Class, class ..._Param>
        -: 3001:struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>
        -: 3002:    : private __check_complete<_Class>
        -: 3003:{
        -: 3004:};
        -: 3005:
        -: 3006:template <class _Rp, class _Class, class ..._Param>
        -: 3007:struct __check_complete<_Rp (_Class::*)(_Param...) &&>
        -: 3008:    : private __check_complete<_Class>
        -: 3009:{
        -: 3010:};
        -: 3011:
        -: 3012:template <class _Rp, class _Class, class ..._Param>
        -: 3013:struct __check_complete<_Rp (_Class::*)(_Param...) const&&>
        -: 3014:    : private __check_complete<_Class>
        -: 3015:{
        -: 3016:};
        -: 3017:
        -: 3018:template <class _Rp, class _Class, class ..._Param>
        -: 3019:struct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>
        -: 3020:    : private __check_complete<_Class>
        -: 3021:{
        -: 3022:};
        -: 3023:
        -: 3024:template <class _Rp, class _Class, class ..._Param>
        -: 3025:struct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>
        -: 3026:    : private __check_complete<_Class>
        -: 3027:{
        -: 3028:};
        -: 3029:
        -: 3030:#endif
        -: 3031:
        -: 3032:template <class _Rp, class _Class>
        -: 3033:struct __check_complete<_Rp _Class::*>
        -: 3034:    : private __check_complete<_Class>
        -: 3035:{
        -: 3036:};
        -: 3037:
        -: 3038:// __invoke forward declarations
        -: 3039:
        -: 3040:// fall back - none of the bullets
        -: 3041:
        -: 3042:template <class ..._Args>
        -: 3043:auto
        -: 3044:__invoke(__any, _Args&& ...__args)
        -: 3045:    -> __nat;
        -: 3046:
        -: 3047:// bullets 1 and 2
        -: 3048:
        -: 3049:template <class _Fp, class _A0, class ..._Args,
        -: 3050:            class = typename enable_if
        -: 3051:            <
        -: 3052:                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&
        -: 3053:                is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,
        -: 3054:                           typename remove_reference<_A0>::type>::value
        -: 3055:            >::type
        -: 3056:         >
        -: 3057:_LIBCPP_INLINE_VISIBILITY
        -: 3058:auto
        -: 3059:__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 3060:    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...));
        -: 3061:
        -: 3062:template <class _Fp, class _A0, class ..._Args,
        -: 3063:            class = typename enable_if
        -: 3064:            <
        -: 3065:                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&
        -: 3066:                !is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,
        -: 3067:                           typename remove_reference<_A0>::type>::value
        -: 3068:            >::type
        -: 3069:         >
        -: 3070:_LIBCPP_INLINE_VISIBILITY
        -: 3071:auto
        -: 3072:__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -: 3073:    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...));
        -: 3074:
        -: 3075:// bullets 3 and 4
        -: 3076:
        -: 3077:template <class _Fp, class _A0,
        -: 3078:            class = typename enable_if
        -: 3079:            <
        -: 3080:                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&
        -: 3081:                is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,
        -: 3082:                           typename remove_reference<_A0>::type>::value
        -: 3083:            >::type
        -: 3084:         >
        -: 3085:_LIBCPP_INLINE_VISIBILITY
        -: 3086:auto
        -: 3087:__invoke(_Fp&& __f, _A0&& __a0)
        -: 3088:    -> decltype(_VSTD::forward<_A0>(__a0).*__f);
        -: 3089:
        -: 3090:template <class _Fp, class _A0,
        -: 3091:            class = typename enable_if
        -: 3092:            <
        -: 3093:                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&
        -: 3094:                !is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,
        -: 3095:                           typename remove_reference<_A0>::type>::value
        -: 3096:            >::type
        -: 3097:         >
        -: 3098:_LIBCPP_INLINE_VISIBILITY
        -: 3099:auto
        -: 3100:__invoke(_Fp&& __f, _A0&& __a0)
        -: 3101:    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f);
        -: 3102:
        -: 3103:// bullet 5
        -: 3104:
        -: 3105:template <class _Fp, class ..._Args>
        -: 3106:_LIBCPP_INLINE_VISIBILITY
        -: 3107:auto
        -: 3108:__invoke(_Fp&& __f, _Args&& ...__args)
        -: 3109:    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...));
        -: 3110:
        -: 3111:// __invokable
        -: 3112:
        -: 3113:template <class _Fp, class ..._Args>
        -: 3114:struct __invokable_imp
        -: 3115:    : private __check_complete<_Fp>
        -: 3116:{
        -: 3117:    typedef decltype(
        -: 3118:            __invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)
        -: 3119:                    ) type;
        -: 3120:    static const bool value = !is_same<type, __nat>::value;
        -: 3121:};
        -: 3122:
        -: 3123:template <class _Fp, class ..._Args>
        -: 3124:struct __invokable
        -: 3125:    : public integral_constant<bool,
        -: 3126:          __invokable_imp<_Fp, _Args...>::value>
        -: 3127:{
        -: 3128:};
        -: 3129:
        -: 3130:// __invoke_of
        -: 3131:
        -: 3132:template <bool _Invokable, class _Fp, class ..._Args>
        -: 3133:struct __invoke_of_imp  // false
        -: 3134:{
        -: 3135:};
        -: 3136:
        -: 3137:template <class _Fp, class ..._Args>
        -: 3138:struct __invoke_of_imp<true, _Fp, _Args...>
        -: 3139:{
        -: 3140:    typedef typename __invokable_imp<_Fp, _Args...>::type type;
        -: 3141:};
        -: 3142:
        -: 3143:template <class _Fp, class ..._Args>
        -: 3144:struct __invoke_of
        -: 3145:    : public __invoke_of_imp<__invokable<_Fp, _Args...>::value, _Fp, _Args...>
        -: 3146:{
        -: 3147:};
        -: 3148:
        -: 3149:template <class _Fp, class ..._Args>
        -: 3150:class _LIBCPP_TYPE_VIS_ONLY result_of<_Fp(_Args...)>
        -: 3151:    : public __invoke_of<_Fp, _Args...>
        -: 3152:{
        -: 3153:};
        -: 3154:
        -: 3155:#if _LIBCPP_STD_VER > 11
        -: 3156:template <class _Tp> using result_of_t = typename result_of<_Tp>::type;
        -: 3157:#endif
        -: 3158:
        -: 3159:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -: 3160:
        -: 3161:template <class _Tp>
        -: 3162:inline _LIBCPP_INLINE_VISIBILITY
        -: 3163:#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE
        -: 3164:typename enable_if
        -: 3165:<
        -: 3166:    is_move_constructible<_Tp>::value &&
        -: 3167:    is_move_assignable<_Tp>::value
        -: 3168:>::type
        -: 3169:#else
        -: 3170:void
        -: 3171:#endif
        -: 3172:swap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&
        -: 3173:                                    is_nothrow_move_assignable<_Tp>::value)
        -: 3174:{
        -: 3175:    _Tp __t(_VSTD::move(__x));
        -: 3176:    __x = _VSTD::move(__y);
        -: 3177:    __y = _VSTD::move(__t);
        -: 3178:}
        -: 3179:
        -: 3180:template <class _ForwardIterator1, class _ForwardIterator2>
        -: 3181:inline _LIBCPP_INLINE_VISIBILITY
        -: 3182:void
        -: 3183:iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        -: 3184:    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))
        -: 3185:               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),
        -: 3186:                                          *_VSTD::declval<_ForwardIterator2>())))
        -: 3187:{
        -: 3188:    swap(*__a, *__b);
        -: 3189:}
        -: 3190:
        -: 3191:// __swappable
        -: 3192:
        -: 3193:namespace __detail
        -: 3194:{
        -: 3195:
        -: 3196:using _VSTD::swap;
        -: 3197:__nat swap(__any, __any);
        -: 3198:
        -: 3199:template <class _Tp>
        -: 3200:struct __swappable
        -: 3201:{
        -: 3202:    typedef decltype(swap(_VSTD::declval<_Tp&>(), _VSTD::declval<_Tp&>())) type;
        -: 3203:    static const bool value = !is_same<type, __nat>::value;
        -: 3204:};
        -: 3205:
        -: 3206:}  // __detail
        -: 3207:
        -: 3208:template <class _Tp>
        -: 3209:struct __is_swappable
        -: 3210:    : public integral_constant<bool, __detail::__swappable<_Tp>::value>
        -: 3211:{
        -: 3212:};
        -: 3213:
        -: 3214:#if __has_feature(cxx_noexcept)
        -: 3215:
        -: 3216:template <bool, class _Tp>
        -: 3217:struct __is_nothrow_swappable_imp
        -: 3218:    : public integral_constant<bool, noexcept(swap(_VSTD::declval<_Tp&>(),
        -: 3219:                                                   _VSTD::declval<_Tp&>()))>
        -: 3220:{
        -: 3221:};
        -: 3222:
        -: 3223:template <class _Tp>
        -: 3224:struct __is_nothrow_swappable_imp<false, _Tp>
        -: 3225:    : public false_type
        -: 3226:{
        -: 3227:};
        -: 3228:
        -: 3229:template <class _Tp>
        -: 3230:struct __is_nothrow_swappable
        -: 3231:    : public __is_nothrow_swappable_imp<__is_swappable<_Tp>::value, _Tp>
        -: 3232:{
        -: 3233:};
        -: 3234:
        -: 3235:#else  // __has_feature(cxx_noexcept)
        -: 3236:
        -: 3237:template <class _Tp>
        -: 3238:struct __is_nothrow_swappable
        -: 3239:    : public false_type
        -: 3240:{
        -: 3241:};
        -: 3242:
        -: 3243:#endif  // __has_feature(cxx_noexcept)
        -: 3244:
        -: 3245:#ifdef _LIBCXX_UNDERLYING_TYPE
        -: 3246:
        -: 3247:template <class _Tp>
        -: 3248:struct underlying_type
        -: 3249:{
        -: 3250:    typedef _LIBCXX_UNDERLYING_TYPE(_Tp) type;
        -: 3251:};
        -: 3252:
        -: 3253:#if _LIBCPP_STD_VER > 11
        -: 3254:template <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;
        -: 3255:#endif
        -: 3256:
        -: 3257:#else  // _LIBCXX_UNDERLYING_TYPE
        -: 3258:
        -: 3259:template <class _Tp, bool _Support = false>
        -: 3260:struct underlying_type
        -: 3261:{
        -: 3262:    static_assert(_Support, "The underyling_type trait requires compiler "
        -: 3263:                            "support. Either no such support exists or "
        -: 3264:                            "libc++ does not know how to use it.");
        -: 3265:};
        -: 3266:
        -: 3267:#endif // _LIBCXX_UNDERLYING_TYPE
        -: 3268:
        -: 3269:#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE
        -: 3270:
        -: 3271:template <class _Tp>
        -: 3272:struct __has_operator_addressof_imp
        -: 3273:{
        -: 3274:    template <class>
        -: 3275:        static auto __test(__any) -> false_type;
        -: 3276:    template <class _Up>
        -: 3277:        static auto __test(_Up* __u)
        -: 3278:            -> typename __select_2nd<decltype(__u->operator&()), true_type>::type;
        -: 3279:
        -: 3280:    static const bool value = decltype(__test<_Tp>(nullptr))::value;
        -: 3281:};
        -: 3282:
        -: 3283:template <class _Tp>
        -: 3284:struct __has_operator_addressof
        -: 3285:    : public integral_constant<bool, __has_operator_addressof_imp<_Tp>::value>
        -: 3286:{};
        -: 3287:
        -: 3288:#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE
        -: 3289:
        -: 3290:_LIBCPP_END_NAMESPACE_STD
        -: 3291:
        -: 3292:#endif  // _LIBCPP_TYPE_TRAITS
