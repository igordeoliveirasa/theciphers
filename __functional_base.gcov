        -:    0:Source:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/c++/v1/__functional_base
        -:    0:Graph:./DerivedData/theciphers/Build/Intermediates/theciphers.build/Debug/unit_tests.build/Objects-normal/x86_64/aes_cipher.gcno
        -:    0:Data:./DerivedData/theciphers/Build/Intermediates/theciphers.build/Debug/unit_tests.build/Objects-normal/x86_64/aes_cipher.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===----------------------------------------------------------------------===//
        -:    3://
        -:    4://                     The LLVM Compiler Infrastructure
        -:    5://
        -:    6:// This file is dual licensed under the MIT and the University of Illinois Open
        -:    7:// Source Licenses. See LICENSE.TXT for details.
        -:    8://
        -:    9://===----------------------------------------------------------------------===//
        -:   10:
        -:   11:#ifndef _LIBCPP_FUNCTIONAL_BASE
        -:   12:#define _LIBCPP_FUNCTIONAL_BASE
        -:   13:
        -:   14:#include <__config>
        -:   15:#include <type_traits>
        -:   16:#include <typeinfo>
        -:   17:#include <exception>
        -:   18:#include <new>
        -:   19:
        -:   20:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:   21:#pragma GCC system_header
        -:   22:#endif
        -:   23:
        -:   24:_LIBCPP_BEGIN_NAMESPACE_STD
        -:   25:
        -:   26:template <class _Arg, class _Result>
        -:   27:struct _LIBCPP_TYPE_VIS_ONLY unary_function
        -:   28:{
        -:   29:    typedef _Arg    argument_type;
        -:   30:    typedef _Result result_type;
        -:   31:};
        -:   32:
        -:   33:template <class _Arg1, class _Arg2, class _Result>
        -:   34:struct _LIBCPP_TYPE_VIS_ONLY binary_function
        -:   35:{
        -:   36:    typedef _Arg1   first_argument_type;
        -:   37:    typedef _Arg2   second_argument_type;
        -:   38:    typedef _Result result_type;
        -:   39:};
        -:   40:
        -:   41:template <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY hash;
        -:   42:
        -:   43:template <class _Tp>
        -:   44:struct __has_result_type
        -:   45:{
        -:   46:private:
        -:   47:    struct __two {char __lx; char __lxx;};
        -:   48:    template <class _Up> static __two __test(...);
        -:   49:    template <class _Up> static char __test(typename _Up::result_type* = 0);
        -:   50:public:
        -:   51:    static const bool value = sizeof(__test<_Tp>(0)) == 1;
        -:   52:};
        -:   53:
        -:   54:#if _LIBCPP_STD_VER > 11
        -:   55:template <class _Tp = void>
        -:   56:#else
        -:   57:template <class _Tp>
        -:   58:#endif
        -:   59:struct _LIBCPP_TYPE_VIS_ONLY less : binary_function<_Tp, _Tp, bool>
        -:   60:{
        -:   61:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY 
        -:   62:    bool operator()(const _Tp& __x, const _Tp& __y) const
        -:   63:        {return __x < __y;}
        -:   64:};
        -:   65:
        -:   66:#if _LIBCPP_STD_VER > 11
        -:   67:template <>
        -:   68:struct _LIBCPP_TYPE_VIS_ONLY less<void>
        -:   69:{
        -:   70:    template <class _T1, class _T2> 
        -:   71:    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY
        -:   72:    auto operator()(_T1&& __t, _T2&& __u) const
        -:   73:        { return _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }
        -:   74:    typedef void is_transparent;
        -:   75:};
        -:   76:#endif
        -:   77:
        -:   78:// addressof
        -:   79:
        -:   80:template <class _Tp>
        -:   81:inline _LIBCPP_INLINE_VISIBILITY
        -:   82:_Tp*
    #####:   83:addressof(_Tp& __x) _NOEXCEPT
        -:   84:{
    #####:   85:    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);
        -:   86:}
        -:   87:
        -:   88:#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)
        -:   89:// Objective-C++ Automatic Reference Counting uses qualified pointers
        -:   90:// that require special addressof() signatures. When
        -:   91:// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler
        -:   92:// itself is providing these definitions. Otherwise, we provide them.
        -:   93:template <class _Tp>
        -:   94:inline _LIBCPP_INLINE_VISIBILITY
        -:   95:__strong _Tp*
        -:   96:addressof(__strong _Tp& __x) _NOEXCEPT
        -:   97:{
        -:   98:  return &__x;
        -:   99:}
        -:  100:
        -:  101:#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK
        -:  102:template <class _Tp>
        -:  103:inline _LIBCPP_INLINE_VISIBILITY
        -:  104:__weak _Tp*
        -:  105:addressof(__weak _Tp& __x) _NOEXCEPT
        -:  106:{
        -:  107:  return &__x;
        -:  108:}
        -:  109:#endif
        -:  110:
        -:  111:template <class _Tp>
        -:  112:inline _LIBCPP_INLINE_VISIBILITY
        -:  113:__autoreleasing _Tp*
        -:  114:addressof(__autoreleasing _Tp& __x) _NOEXCEPT
        -:  115:{
        -:  116:  return &__x;
        -:  117:}
        -:  118:
        -:  119:template <class _Tp>
        -:  120:inline _LIBCPP_INLINE_VISIBILITY
        -:  121:__unsafe_unretained _Tp*
        -:  122:addressof(__unsafe_unretained _Tp& __x) _NOEXCEPT
        -:  123:{
        -:  124:  return &__x;
        -:  125:}
        -:  126:#endif
        -:  127:
        -:  128:#ifdef _LIBCPP_HAS_NO_VARIADICS
        -:  129:
        -:  130:#include <__functional_base_03>
        -:  131:
        -:  132:#else  // _LIBCPP_HAS_NO_VARIADICS
        -:  133:
        -:  134:// __weak_result_type
        -:  135:
        -:  136:template <class _Tp>
        -:  137:struct __derives_from_unary_function
        -:  138:{
        -:  139:private:
        -:  140:    struct __two {char __lx; char __lxx;};
        -:  141:    static __two __test(...);
        -:  142:    template <class _Ap, class _Rp>
        -:  143:        static unary_function<_Ap, _Rp>
        -:  144:        __test(const volatile unary_function<_Ap, _Rp>*);
        -:  145:public:
        -:  146:    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
        -:  147:    typedef decltype(__test((_Tp*)0)) type;
        -:  148:};
        -:  149:
        -:  150:template <class _Tp>
        -:  151:struct __derives_from_binary_function
        -:  152:{
        -:  153:private:
        -:  154:    struct __two {char __lx; char __lxx;};
        -:  155:    static __two __test(...);
        -:  156:    template <class _A1, class _A2, class _Rp>
        -:  157:        static binary_function<_A1, _A2, _Rp>
        -:  158:        __test(const volatile binary_function<_A1, _A2, _Rp>*);
        -:  159:public:
        -:  160:    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;
        -:  161:    typedef decltype(__test((_Tp*)0)) type;
        -:  162:};
        -:  163:
        -:  164:template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
        -:  165:struct __maybe_derive_from_unary_function  // bool is true
        -:  166:    : public __derives_from_unary_function<_Tp>::type
        -:  167:{
        -:  168:};
        -:  169:
        -:  170:template <class _Tp>
        -:  171:struct __maybe_derive_from_unary_function<_Tp, false>
        -:  172:{
        -:  173:};
        -:  174:
        -:  175:template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
        -:  176:struct __maybe_derive_from_binary_function  // bool is true
        -:  177:    : public __derives_from_binary_function<_Tp>::type
        -:  178:{
        -:  179:};
        -:  180:
        -:  181:template <class _Tp>
        -:  182:struct __maybe_derive_from_binary_function<_Tp, false>
        -:  183:{
        -:  184:};
        -:  185:
        -:  186:template <class _Tp, bool = __has_result_type<_Tp>::value>
        -:  187:struct __weak_result_type_imp // bool is true
        -:  188:    : public __maybe_derive_from_unary_function<_Tp>,
        -:  189:      public __maybe_derive_from_binary_function<_Tp>
        -:  190:{
        -:  191:    typedef typename _Tp::result_type result_type;
        -:  192:};
        -:  193:
        -:  194:template <class _Tp>
        -:  195:struct __weak_result_type_imp<_Tp, false>
        -:  196:    : public __maybe_derive_from_unary_function<_Tp>,
        -:  197:      public __maybe_derive_from_binary_function<_Tp>
        -:  198:{
        -:  199:};
        -:  200:
        -:  201:template <class _Tp>
        -:  202:struct __weak_result_type
        -:  203:    : public __weak_result_type_imp<_Tp>
        -:  204:{
        -:  205:};
        -:  206:
        -:  207:// 0 argument case
        -:  208:
        -:  209:template <class _Rp>
        -:  210:struct __weak_result_type<_Rp ()>
        -:  211:{
        -:  212:    typedef _Rp result_type;
        -:  213:};
        -:  214:
        -:  215:template <class _Rp>
        -:  216:struct __weak_result_type<_Rp (&)()>
        -:  217:{
        -:  218:    typedef _Rp result_type;
        -:  219:};
        -:  220:
        -:  221:template <class _Rp>
        -:  222:struct __weak_result_type<_Rp (*)()>
        -:  223:{
        -:  224:    typedef _Rp result_type;
        -:  225:};
        -:  226:
        -:  227:// 1 argument case
        -:  228:
        -:  229:template <class _Rp, class _A1>
        -:  230:struct __weak_result_type<_Rp (_A1)>
        -:  231:    : public unary_function<_A1, _Rp>
        -:  232:{
        -:  233:};
        -:  234:
        -:  235:template <class _Rp, class _A1>
        -:  236:struct __weak_result_type<_Rp (&)(_A1)>
        -:  237:    : public unary_function<_A1, _Rp>
        -:  238:{
        -:  239:};
        -:  240:
        -:  241:template <class _Rp, class _A1>
        -:  242:struct __weak_result_type<_Rp (*)(_A1)>
        -:  243:    : public unary_function<_A1, _Rp>
        -:  244:{
        -:  245:};
        -:  246:
        -:  247:template <class _Rp, class _Cp>
        -:  248:struct __weak_result_type<_Rp (_Cp::*)()>
        -:  249:    : public unary_function<_Cp*, _Rp>
        -:  250:{
        -:  251:};
        -:  252:
        -:  253:template <class _Rp, class _Cp>
        -:  254:struct __weak_result_type<_Rp (_Cp::*)() const>
        -:  255:    : public unary_function<const _Cp*, _Rp>
        -:  256:{
        -:  257:};
        -:  258:
        -:  259:template <class _Rp, class _Cp>
        -:  260:struct __weak_result_type<_Rp (_Cp::*)() volatile>
        -:  261:    : public unary_function<volatile _Cp*, _Rp>
        -:  262:{
        -:  263:};
        -:  264:
        -:  265:template <class _Rp, class _Cp>
        -:  266:struct __weak_result_type<_Rp (_Cp::*)() const volatile>
        -:  267:    : public unary_function<const volatile _Cp*, _Rp>
        -:  268:{
        -:  269:};
        -:  270:
        -:  271:// 2 argument case
        -:  272:
        -:  273:template <class _Rp, class _A1, class _A2>
        -:  274:struct __weak_result_type<_Rp (_A1, _A2)>
        -:  275:    : public binary_function<_A1, _A2, _Rp>
        -:  276:{
        -:  277:};
        -:  278:
        -:  279:template <class _Rp, class _A1, class _A2>
        -:  280:struct __weak_result_type<_Rp (*)(_A1, _A2)>
        -:  281:    : public binary_function<_A1, _A2, _Rp>
        -:  282:{
        -:  283:};
        -:  284:
        -:  285:template <class _Rp, class _A1, class _A2>
        -:  286:struct __weak_result_type<_Rp (&)(_A1, _A2)>
        -:  287:    : public binary_function<_A1, _A2, _Rp>
        -:  288:{
        -:  289:};
        -:  290:
        -:  291:template <class _Rp, class _Cp, class _A1>
        -:  292:struct __weak_result_type<_Rp (_Cp::*)(_A1)>
        -:  293:    : public binary_function<_Cp*, _A1, _Rp>
        -:  294:{
        -:  295:};
        -:  296:
        -:  297:template <class _Rp, class _Cp, class _A1>
        -:  298:struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
        -:  299:    : public binary_function<const _Cp*, _A1, _Rp>
        -:  300:{
        -:  301:};
        -:  302:
        -:  303:template <class _Rp, class _Cp, class _A1>
        -:  304:struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
        -:  305:    : public binary_function<volatile _Cp*, _A1, _Rp>
        -:  306:{
        -:  307:};
        -:  308:
        -:  309:template <class _Rp, class _Cp, class _A1>
        -:  310:struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
        -:  311:    : public binary_function<const volatile _Cp*, _A1, _Rp>
        -:  312:{
        -:  313:};
        -:  314:
        -:  315:// 3 or more arguments
        -:  316:
        -:  317:template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
        -:  318:struct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>
        -:  319:{
        -:  320:    typedef _Rp result_type;
        -:  321:};
        -:  322:
        -:  323:template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
        -:  324:struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>
        -:  325:{
        -:  326:    typedef _Rp result_type;
        -:  327:};
        -:  328:
        -:  329:template <class _Rp, class _A1, class _A2, class _A3, class ..._A4>
        -:  330:struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>
        -:  331:{
        -:  332:    typedef _Rp result_type;
        -:  333:};
        -:  334:
        -:  335:template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
        -:  336:struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>
        -:  337:{
        -:  338:    typedef _Rp result_type;
        -:  339:};
        -:  340:
        -:  341:template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
        -:  342:struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>
        -:  343:{
        -:  344:    typedef _Rp result_type;
        -:  345:};
        -:  346:
        -:  347:template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
        -:  348:struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>
        -:  349:{
        -:  350:    typedef _Rp result_type;
        -:  351:};
        -:  352:
        -:  353:template <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>
        -:  354:struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>
        -:  355:{
        -:  356:    typedef _Rp result_type;
        -:  357:};
        -:  358:
        -:  359:// __invoke
        -:  360:
        -:  361:// bullets 1 and 2
        -:  362:
        -:  363:template <class _Fp, class _A0, class ..._Args,
        -:  364:            class>
        -:  365:inline _LIBCPP_INLINE_VISIBILITY
        -:  366:auto
        -:  367:__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -:  368:    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))
        -:  369:{
        -:  370:    return (_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...);
        -:  371:}
        -:  372:
        -:  373:template <class _Fp, class _A0, class ..._Args,
        -:  374:            class>
        -:  375:inline _LIBCPP_INLINE_VISIBILITY
        -:  376:auto
        -:  377:__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)
        -:  378:    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))
        -:  379:{
        -:  380:    return ((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...);
        -:  381:}
        -:  382:
        -:  383:// bullets 3 and 4
        -:  384:
        -:  385:template <class _Fp, class _A0,
        -:  386:            class>
        -:  387:inline _LIBCPP_INLINE_VISIBILITY
        -:  388:auto
        -:  389:__invoke(_Fp&& __f, _A0&& __a0)
        -:  390:    -> decltype(_VSTD::forward<_A0>(__a0).*__f)
        -:  391:{
        -:  392:    return _VSTD::forward<_A0>(__a0).*__f;
        -:  393:}
        -:  394:
        -:  395:template <class _Fp, class _A0,
        -:  396:            class>
        -:  397:inline _LIBCPP_INLINE_VISIBILITY
        -:  398:auto
        -:  399:__invoke(_Fp&& __f, _A0&& __a0)
        -:  400:    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f)
        -:  401:{
        -:  402:    return (*_VSTD::forward<_A0>(__a0)).*__f;
        -:  403:}
        -:  404:
        -:  405:// bullet 5
        -:  406:
        -:  407:template <class _Fp, class ..._Args>
        -:  408:inline _LIBCPP_INLINE_VISIBILITY
        -:  409:auto
        -:  410:__invoke(_Fp&& __f, _Args&& ...__args)
        -:  411:    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))
        -:  412:{
        -:  413:    return _VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...);
        -:  414:}
        -:  415:
        -:  416:template <class _Tp, class ..._Args>
        -:  417:struct __invoke_return
        -:  418:{
        -:  419:    typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;
        -:  420:};
        -:  421:
        -:  422:template <class _Tp>
        -:  423:class _LIBCPP_TYPE_VIS_ONLY reference_wrapper
        -:  424:    : public __weak_result_type<_Tp>
        -:  425:{
        -:  426:public:
        -:  427:    // types
        -:  428:    typedef _Tp type;
        -:  429:private:
        -:  430:    type* __f_;
        -:  431:
        -:  432:public:
        -:  433:    // construct/copy/destroy
        -:  434:    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT
        -:  435:        : __f_(_VSTD::addressof(__f)) {}
        -:  436:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  437:    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps
        -:  438:#endif
        -:  439:
        -:  440:    // access
        -:  441:    _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}
        -:  442:    _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}
        -:  443:
        -:  444:    // invoke
        -:  445:    template <class... _ArgTypes>
        -:  446:       _LIBCPP_INLINE_VISIBILITY
        -:  447:       typename __invoke_of<type&, _ArgTypes...>::type
        -:  448:          operator() (_ArgTypes&&... __args) const
        -:  449:          {
        -:  450:              return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);
        -:  451:          }
        -:  452:};
        -:  453:
        -:  454:template <class _Tp> struct ____is_reference_wrapper : public false_type {};
        -:  455:template <class _Tp> struct ____is_reference_wrapper<reference_wrapper<_Tp> > : public true_type {};
        -:  456:template <class _Tp> struct __is_reference_wrapper
        -:  457:    : public ____is_reference_wrapper<typename remove_cv<_Tp>::type> {};
        -:  458:
        -:  459:template <class _Tp>
        -:  460:inline _LIBCPP_INLINE_VISIBILITY
        -:  461:reference_wrapper<_Tp>
        -:  462:ref(_Tp& __t) _NOEXCEPT
        -:  463:{
        -:  464:    return reference_wrapper<_Tp>(__t);
        -:  465:}
        -:  466:
        -:  467:template <class _Tp>
        -:  468:inline _LIBCPP_INLINE_VISIBILITY
        -:  469:reference_wrapper<_Tp>
        -:  470:ref(reference_wrapper<_Tp> __t) _NOEXCEPT
        -:  471:{
        -:  472:    return ref(__t.get());
        -:  473:}
        -:  474:
        -:  475:template <class _Tp>
        -:  476:inline _LIBCPP_INLINE_VISIBILITY
        -:  477:reference_wrapper<const _Tp>
        -:  478:cref(const _Tp& __t) _NOEXCEPT
        -:  479:{
        -:  480:    return reference_wrapper<const _Tp>(__t);
        -:  481:}
        -:  482:
        -:  483:template <class _Tp>
        -:  484:inline _LIBCPP_INLINE_VISIBILITY
        -:  485:reference_wrapper<const _Tp>
        -:  486:cref(reference_wrapper<_Tp> __t) _NOEXCEPT
        -:  487:{
        -:  488:    return cref(__t.get());
        -:  489:}
        -:  490:
        -:  491:#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  492:#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
        -:  493:
        -:  494:template <class _Tp> void ref(const _Tp&&) = delete;
        -:  495:template <class _Tp> void cref(const _Tp&&) = delete;
        -:  496:
        -:  497:#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
        -:  498:
        -:  499:template <class _Tp> void ref(const _Tp&&);// = delete;
        -:  500:template <class _Tp> void cref(const _Tp&&);// = delete;
        -:  501:
        -:  502:#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS
        -:  503:
        -:  504:#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
        -:  505:
        -:  506:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -:  507:
        -:  508:#if _LIBCPP_STD_VER > 11
        -:  509:template <class _Tp1, class _Tp2 = void>
        -:  510:struct __is_transparent
        -:  511:{
        -:  512:private:
        -:  513:    struct __two {char __lx; char __lxx;};
        -:  514:    template <class _Up> static __two __test(...);
        -:  515:    template <class _Up> static char __test(typename _Up::is_transparent* = 0);
        -:  516:public:
        -:  517:    static const bool value = sizeof(__test<_Tp1>(0)) == 1;
        -:  518:};
        -:  519:#endif
        -:  520:
        -:  521:// allocator_arg_t
        -:  522:
        -:  523:struct _LIBCPP_TYPE_VIS_ONLY allocator_arg_t { };
        -:  524:
        -:  525:#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_MEMORY)
        -:  526:extern const allocator_arg_t allocator_arg;
        -:  527:#else
        -:  528:constexpr allocator_arg_t allocator_arg = allocator_arg_t();
        -:  529:#endif
        -:  530:
        -:  531:// uses_allocator
        -:  532:
        -:  533:template <class _Tp>
        -:  534:struct __has_allocator_type
        -:  535:{
        -:  536:private:
        -:  537:    struct __two {char __lx; char __lxx;};
        -:  538:    template <class _Up> static __two __test(...);
        -:  539:    template <class _Up> static char __test(typename _Up::allocator_type* = 0);
        -:  540:public:
        -:  541:    static const bool value = sizeof(__test<_Tp>(0)) == 1;
        -:  542:};
        -:  543:
        -:  544:template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
        -:  545:struct __uses_allocator
        -:  546:    : public integral_constant<bool,
        -:  547:        is_convertible<_Alloc, typename _Tp::allocator_type>::value>
        -:  548:{
        -:  549:};
        -:  550:
        -:  551:template <class _Tp, class _Alloc>
        -:  552:struct __uses_allocator<_Tp, _Alloc, false>
        -:  553:    : public false_type
        -:  554:{
        -:  555:};
        -:  556:
        -:  557:template <class _Tp, class _Alloc>
        -:  558:struct _LIBCPP_TYPE_VIS_ONLY uses_allocator
        -:  559:    : public __uses_allocator<_Tp, _Alloc>
        -:  560:{
        -:  561:};
        -:  562:
        -:  563:#ifndef _LIBCPP_HAS_NO_VARIADICS
        -:  564:
        -:  565:// allocator construction
        -:  566:
        -:  567:template <class _Tp, class _Alloc, class ..._Args>
        -:  568:struct __uses_alloc_ctor_imp
        -:  569:{
        -:  570:    static const bool __ua = uses_allocator<_Tp, _Alloc>::value;
        -:  571:    static const bool __ic =
        -:  572:        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
        -:  573:    static const int value = __ua ? 2 - __ic : 0;
        -:  574:};
        -:  575:
        -:  576:template <class _Tp, class _Alloc, class ..._Args>
        -:  577:struct __uses_alloc_ctor
        -:  578:    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>
        -:  579:    {};
        -:  580:
        -:  581:template <class _Tp, class _Allocator, class... _Args>
        -:  582:inline _LIBCPP_INLINE_VISIBILITY
        -:  583:void __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )
        -:  584:{
        -:  585:    new (__storage) _Tp (_VSTD::forward<_Args>(__args)...);
        -:  586:}
        -:  587:
        -:  588:template <class _Tp, class _Allocator, class... _Args>
        -:  589:inline _LIBCPP_INLINE_VISIBILITY
        -:  590:void __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
        -:  591:{
        -:  592:    new (__storage) _Tp (allocator_arg, __a, _VSTD::forward<_Args>(__args)...);
        -:  593:}
        -:  594:
        -:  595:template <class _Tp, class _Allocator, class... _Args>
        -:  596:inline _LIBCPP_INLINE_VISIBILITY
        -:  597:void __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )
        -:  598:{
        -:  599:    new (__storage) _Tp (_VSTD::forward<_Args>(__args)..., __a);
        -:  600:}
        -:  601:
        -:  602:template <class _Tp, class _Allocator, class... _Args>
        -:  603:inline _LIBCPP_INLINE_VISIBILITY
        -:  604:void __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)
        -:  605:{ 
        -:  606:    __user_alloc_construct_impl( 
        -:  607:             __uses_alloc_ctor<_Tp, _Allocator>(), 
        -:  608:             __storage, __a, _VSTD::forward<_Args>(__args)...
        -:  609:        );
        -:  610:}
        -:  611:#endif  // _LIBCPP_HAS_NO_VARIADICS
        -:  612:
        -:  613:_LIBCPP_END_NAMESPACE_STD
        -:  614:
        -:  615:#endif  // _LIBCPP_FUNCTIONAL_BASE
